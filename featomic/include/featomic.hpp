#ifndef FEATOMIC_HPP
#define FEATOMIC_HPP

#include <cstring>
#include <cstdint>

#include <array>
#include <string>
#include <vector>
#include <mutex>
#include <utility>
#include <optional>
#include <stdexcept>
#include <exception>
#include <unordered_map>

#include "metatensor.h"
#include "metatensor.hpp"
#include "featomic.h"

/// This file contains the C++ API to featomic, manually built on top of the C
/// API defined in `featomic.h`. This API uses the standard C++ library where
/// convenient, but also allow to drop back to the C API if required, by
/// providing functions to extract the C API handles (named `as_featomic_XXX`).

namespace featomic {

/// Exception class for all error thrown by featomic
class FeatomicError : public std::runtime_error {
public:
    /// Create a new error with the given message
    FeatomicError(const std::string& message): std::runtime_error(message) {}
    ~FeatomicError() override = default;

    /// FeatomicError is copy-constructible
    FeatomicError(const FeatomicError&) = default;
    /// FeatomicError is move-constructible
    FeatomicError(FeatomicError&&) = default;
    /// FeatomicError can be copy-assigned
    FeatomicError& operator=(const FeatomicError&) = default;
    /// FeatomicError can be move-assigned
    FeatomicError& operator=(FeatomicError&&) = default;
};

namespace details {
    /// Class able to store exceptions and retrieve them later
    class ExceptionsStore {
    public:
        ExceptionsStore() = default;

        ExceptionsStore(const ExceptionsStore&) = delete;
        ExceptionsStore(ExceptionsStore&&) = delete;
        ExceptionsStore& operator=(const ExceptionsStore&) = delete;
        ExceptionsStore& operator=(ExceptionsStore&&) = delete;

        /// Save an exception pointer inside the exceptions store and return the
        /// corresponding id as a **negative** integer.
        int32_t save_exception(std::exception_ptr exception) {
            auto exception_id = next_id_;

            // this should not underflow, but better safe than sorry
            if (next_id_ == INT32_MIN) {
                throw FeatomicError("too many exceptions, what are you doing???");
            }
            next_id_ -= 1;

            map_.emplace(exception_id, std::move(exception));
            return exception_id;
        }

        /// Get the exception pointer corresponding to the given exception id.
        /// The id **MUST** have been generated by a previous call to
        /// `save_exception`.
        std::exception_ptr extract_exception(int32_t exception_id) {
            auto iterator = map_.find(exception_id);
            if (iterator == map_.end()) {
                throw FeatomicError("internal error: tried to access a non-existing exception");
            }

            auto exception = iterator->second;
            map_.erase(iterator);

            return exception;
        }

    private:
        std::unordered_map<int32_t, std::exception_ptr> map_;
        int32_t next_id_ = -1;
    };

    /// Singleton version of `ExceptionsStore`, protected by a mutex to be safe
    /// to call in multi-threaded context
    class GlobalExceptionsStore {
    public:
        /// Save an exception pointer inside the exceptions store and return the
        /// corresponding id as a **negative** integer.
        static int32_t save_exception(std::exception_ptr exception) {
            const std::lock_guard<std::mutex> lock(GlobalExceptionsStore::mutex());
            auto& store = GlobalExceptionsStore::instance();
            return store.save_exception(exception);
        }

        /// Get the exception pointer corresponding to the given exception id.
        /// The id **MUST** have been generated by a previous call to
        /// `save_exception`.
        static std::exception_ptr extract_exception(int32_t exception_id) {
            const std::lock_guard<std::mutex> lock(GlobalExceptionsStore::mutex());
            auto& store = GlobalExceptionsStore::instance();
            return store.extract_exception(exception_id);
        }

    private:
        /// the actual instance of the store, as a static singleton
        static ExceptionsStore& instance() {
            static ExceptionsStore instance;
            return instance;
        }

        /// mutex used to lock the map in multi-threaded context
        static std::mutex& mutex() {
            static std::mutex mutex;
            return mutex;
        }
    };

    /// Check the status returned by a featomic function, throwing an exception
    /// with the latest error message if the status is not `FEATOMIC_SUCCESS`.
    inline void check_status(featomic_status_t status) {
        if (status > FEATOMIC_SUCCESS) {
            throw FeatomicError(featomic_last_error());
        } else if (status < FEATOMIC_SUCCESS) {
            // this error comes from C++, let's restore it and pass it up
            auto exception = GlobalExceptionsStore::extract_exception(status);
            std::rethrow_exception(exception);
        }
    }
}

#define FEATOMIC_SYSTEM_CATCH_EXCEPTIONS(__code__)                                \
    do {                                                                        \
        try {                                                                   \
            __code__                                                            \
            return FEATOMIC_SUCCESS;                                              \
        } catch (...) {                                                         \
            auto exception = std::current_exception();                          \
            return details::GlobalExceptionsStore::save_exception(              \
                std::move(exception)                                            \
            );                                                                  \
        }                                                                       \
    } while (false)

/// A `System` deals with the storage of atoms and related information, as well
/// as the computation of neighbor lists.
///
/// This class only defines a pure virtual interface for `System`. In order to
/// provide access to new system, users must create a child class implementing
/// all virtual member functions.
class System {
public:
    System() = default;
    virtual ~System() = default;

    /// System is copy-constructible
    System(const System&) = default;
    /// System is move-constructible
    System(System&&) = default;
    /// System can be copy-assigned
    System& operator=(const System&) = default;
    /// System can be move-assigned
    System& operator=(System&&) = default;

    /// Get the number of atoms in this system
    virtual uintptr_t size() const = 0;

    /// Get a pointer to the first element a contiguous array (typically
    /// `std::vector` or memory allocated with `new[]`) containing the atomic
    /// type of each atom in this system. Different atomics types should be
    /// identified with a different value. These values are usually the atomic
    /// number, but don't have to be. The array should contain `System::size()`
    /// elements.
    virtual const int32_t* types() const = 0;

    /// Get a pointer to the first element of a contiguous array containing the
    /// atomic cartesian coordinates. `positions[0], positions[1], positions[2]`
    /// must contain the x, y, z cartesian coordinates of the first atom, and so
    /// on. The array should contain `3 x System::size()` elements.
    virtual const double* positions() const = 0;

    /// Unit cell representation as a 3x3 matrix. The cell should be written in
    /// row major order, i.e. `{{ax ay az}, {bx by bz}, {cx cy cz}}`, where
    /// a/b/c are the unit cell vectors.
    using CellMatrix = std::array<std::array<double, 3>, 3>;

    /// Get the matrix describing the unit cell
    virtual CellMatrix cell() const = 0;

    /// Compute the neighbor list with the given `cutoff`, and store it for
    /// later access using `System::pairs` or `System::pairs_containing`.
    virtual void compute_neighbors(double cutoff) = 0;

    /// Get the list of pairs in this system
    ///
    /// This list of pair should only contain each pair once (and not twice as
    /// `i-j` and `j-i`), should not contain self pairs (`i-i`); and should only
    /// contains pairs where the distance between atoms is actually bellow the
    /// cutoff passed in the last call to `System::compute_neighbors`. This
    /// function is only valid to call after a call to
    /// `System::compute_neighbors`.
    virtual const std::vector<featomic_pair_t>& pairs() const = 0;

    /// Get the list of pairs in this system containing the `atom` at the given
    /// index.
    ///
    /// The same restrictions on the list of pairs as `System::pairs` applies,
    /// with the additional condition that the pair `i-j` should be included
    /// both in the return of `System::pairs_containing(i)` and
    /// `System::pairs_containing(j)`.
    virtual const std::vector<featomic_pair_t>& pairs_containing(uintptr_t atom) const = 0;

    /// Convert a child instance of the `System` class to a `featomic_system_t` to
    /// be passed to the featomic functions.
    ///
    /// This is an advanced function that most users don't need to call
    /// directly.
    featomic_system_t as_featomic_system_t() {
        return featomic_system_t {
            // user_data
            static_cast<void*>(this),
            // size
            [](const void* self, uintptr_t* size) {
                FEATOMIC_SYSTEM_CATCH_EXCEPTIONS(
                    *size = static_cast<const System*>(self)->size();
                );
            },
            // types
            [](const void* self, const int32_t** types) {
                FEATOMIC_SYSTEM_CATCH_EXCEPTIONS(
                    *types = static_cast<const System*>(self)->types();
                );
            },
            // positions
            [](const void* self, const double** positions) {
                FEATOMIC_SYSTEM_CATCH_EXCEPTIONS(
                    *positions = (reinterpret_cast<const System*>(self))->positions();
                );
            },
            // cell
            [](const void* self, double* cell) {
                FEATOMIC_SYSTEM_CATCH_EXCEPTIONS(
                    auto cpp_cell = reinterpret_cast<const System*>(self)->cell();
                    std::memcpy(cell, cpp_cell.data(), 9 * sizeof(double));
                );
            },
            // compute_neighbors
            [](void* self, double cutoff) {
                FEATOMIC_SYSTEM_CATCH_EXCEPTIONS(
                    reinterpret_cast<System*>(self)->compute_neighbors(cutoff);
                );
            },
            // pairs
            [](const void* self, const featomic_pair_t** pairs, uintptr_t* size) {
                FEATOMIC_SYSTEM_CATCH_EXCEPTIONS(
                    const auto& cpp_pairs = reinterpret_cast<const System*>(self)->pairs();
                    *pairs = cpp_pairs.data();
                    *size = cpp_pairs.size();
                );
            },
            // pairs_containing
            [](const void* self, uintptr_t atom, const featomic_pair_t** pairs, uintptr_t* size) {
                FEATOMIC_SYSTEM_CATCH_EXCEPTIONS(
                    const auto& cpp_pairs = reinterpret_cast<const System*>(self)->pairs_containing(atom);
                    *pairs = cpp_pairs.data();
                    *size = cpp_pairs.size();
                );
            }
        };
    }
};

#undef FEATOMIC_SYSTEM_CATCH_EXCEPTIONS


/// A very minimal implementation of the System interface, only providing data
/// and no neighbor list calculation. This class must thus be used with
/// `use_native_system=true` in the calculation options.
class SimpleSystem final: public System {
public:
    /// Create a new `SimpleSystem`, with the atoms contained in the give cell
    SimpleSystem(CellMatrix cell = {{0}}): cell_(cell) {}

    /// Add an atom with the given type and position to this system
    void add_atom(int32_t type, std::array<double, 3> position) {
        this->atomic_types_.push_back(type);
        this->positions_.push_back(position[0]);
        this->positions_.push_back(position[1]);
        this->positions_.push_back(position[2]);
    }

    uintptr_t size() const override {
        return this->atomic_types_.size();
    }

    const int32_t* types() const override {
        return this->atomic_types_.data();
    }

    const double* positions() const override {
        return this->positions_.data();
    }

    CellMatrix cell() const override {
        return cell_;
    }

    void compute_neighbors(double /*cutoff*/) override {
        throw std::runtime_error("SimpleSystem can only be used with `use_native_system=true`");
    }

    const std::vector<featomic_pair_t>& pairs() const override {
        throw std::runtime_error("SimpleSystem can only be used with `use_native_system=true`");
    }

    const std::vector<featomic_pair_t>& pairs_containing(uintptr_t /*atom*/) const override {
        throw std::runtime_error("SimpleSystem can only be used with `use_native_system=true`");
    }

private:
    CellMatrix cell_;
    std::vector<double> positions_;
    std::vector<int32_t> atomic_types_;
};

/// Rules to select labels (either samples or properties) on which the user
/// wants to run a calculation
class LabelsSelection {
public:
    /// Use all possible labels for this calculation
    static LabelsSelection all() {
        return LabelsSelection(std::nullopt, std::nullopt);
    }

    /// Select a subset of labels, using the same selection criterion for all
    /// keys in the final `TensorMap`.
    ///
    /// If the `selection` contains the same variables as the full set of
    /// labels, then only entries from the full set that also appear in this
    /// selection will be used.
    ///
    /// If the `selection` contains a subset of the variables of the full set of
    /// labels, then only entries from the full set which match one of the entry
    /// in this selection for all of the selection variable will be used.
    static LabelsSelection subset(metatensor::Labels selection) {
        return LabelsSelection(std::move(selection), std::nullopt);
    }

    /// Use a predefined subset of labels, with different entries for different
    /// keys of the final `TensorMap`.
    ///
    /// For each key, the corresponding labels are fetched out of the
    /// `selection`, which must have the same set of keys as the full
    /// calculation.
    static LabelsSelection predefined(const metatensor::TensorMap& selection) {
        return LabelsSelection(std::nullopt, selection.clone_metadata_only());
    }

    ~LabelsSelection() = default;

    /// LabelsSelection can be copy-constructed
    LabelsSelection(const LabelsSelection& other): LabelsSelection(std::nullopt, std::nullopt) {
        *this = other;
    }

    /// LabelsSelection can be copy-assigned
    LabelsSelection& operator=(const LabelsSelection& other) {
        this->subset_ = other.subset_;

        if (other.predefined_) {
            this->predefined_ = other.predefined_->clone_metadata_only();
        } else {
            this->predefined_ = std::nullopt;
        }

        if (this->subset_) {
            this->raw_subset_ = subset_->as_mts_labels_t();
        }

        return *this;
    }

    /// LabelsSelection can be move-constructed
    LabelsSelection(LabelsSelection&& other) noexcept : LabelsSelection(std::nullopt, std::nullopt) {
        *this = std::move(other);
    }

    /// LabelsSelection can be move-assigned
    LabelsSelection& operator=(LabelsSelection&& other) noexcept {
        this->subset_ = std::move(other.subset_);
        this->predefined_ = std::move(other.predefined_);
        if (this->subset_) {
            this->raw_subset_ = subset_->as_mts_labels_t();
        }

        other.subset_ = std::nullopt;
        other.predefined_ = std::nullopt;
        std::memset(&other.raw_subset_, 0, sizeof(mts_labels_t));

        return *this;
    }

    /// Get the `featomic_labels_selection_t` corresponding to this LabelsSelection
    featomic_labels_selection_t as_featomic_labels_selection_t() const {
        auto selection = featomic_labels_selection_t{};
        std::memset(&selection, 0, sizeof(featomic_labels_selection_t));

        if (subset_) {
            selection.subset = &raw_subset_;
        }

        if (predefined_) {
            selection.predefined = predefined_.value().as_mts_tensormap_t();
        }

        return selection;
    }

private:
    LabelsSelection(std::optional<metatensor::Labels> subset, std::optional<metatensor::TensorMap> predefined):
        subset_(std::move(subset)), raw_subset_(), predefined_(std::move(predefined))
    {
        std::memset(&raw_subset_, 0, sizeof(mts_labels_t));
        if (subset_) {
            raw_subset_ = subset_->as_mts_labels_t();
        }
    }

    std::optional<metatensor::Labels> subset_;
    mts_labels_t raw_subset_;
    std::optional<metatensor::TensorMap> predefined_;
};


/// Options that can be set to change how a calculator operates.
class CalculationOptions {
public:
    /// Copy the data from systems into native `SimpleSystem`. This can be
    /// faster than having to cross the FFI boundary too often.
    bool use_native_system = false;

    /// Selection of samples on which to run the computation
    LabelsSelection selected_samples = LabelsSelection::all();
    /// Selection of properties to compute for the samples
    LabelsSelection selected_properties = LabelsSelection::all();

    /// Selection for the keys to include in the output. Set this to
    /// `std::nullopt` to use the default set of keys, as determined by the
    /// calculator. Note that this default set of keys can depend on which
    /// systems we are running the calculation on.
    std::optional<metatensor::Labels> selected_keys = std::nullopt;

    /// @verbatim embed:rst:leading-slashes
    /// List of gradients that should be computed. If this list is empty no
    /// gradients are computed.
    ///
    /// The following gradients are available:
    ///
    /// - ``"positions"``, for gradients of the representation with respect to
    ///   atomic positions, with fixed cell matrix parameters. Positions
    ///   gradients are computed as
    ///
    ///   .. math::
    ///       \frac{\partial \langle q \vert A_i \rangle}
    ///            {\partial \mathbf{r_j}}
    ///
    ///   where :math:`\langle q \vert A_i \rangle` is the representation around
    ///   atom :math:`i` and :math:`\mathbf{r_j}` is the position vector of the
    ///   atom :math:`j`.
    ///
    ///   **Note**: Position gradients of an atom are computed with respect to all
    ///   other atoms within the representation. To recover the force one has to
    ///   accumulate all pairs associated with atom :math:`i`.
    ///
    /// - ``"strain"``, for gradients of the representation with respect to
    ///   strain. These gradients are typically used to compute the virial, and
    ///   from there the pressure acting on a system. To compute them, we
    ///   pretend that all the positions :math:`\mathbf r` and unit cell
    ///   :math:`\mathbf H` have been scaled by a strain matrix
    ///   :math:`\epsilon`:
    ///
    ///   .. math::
    ///      \mathbf r &\rightarrow \mathbf r \left(\mathbb{1} + \epsilon \right)\\
    ///      \mathbf H &\rightarrow \mathbf H \left(\mathbb{1} + \epsilon \right)
    ///
    ///   and then take the gradients of the representation with respect to this
    ///   matrix:
    ///
    ///   .. math::
    ///       \frac{\partial \langle q \vert A_i \rangle} {\partial \mathbf{\epsilon}}
    ///
    ///
    /// - ``"cell"``, for gradients of the representation with respect to the
    ///   system's cell parameters. These gradients are computed at fixed
    ///   positions, and often not what you want when computing gradients
    ///   explicitly (they are mainly used in ``featomic.torch`` to integrate
    ///   with backward propagation). If you are trying to compute the virial
    ///   or the stress, you should use ``"strain"`` gradients instead.
    ///
    ///   .. math::
    ///       \left. \frac{\partial \langle q \vert A_i \rangle}
    ///            {\partial \mathbf{H}} \right |_\mathbf{r}
    ///
    /// @endverbatim
    std::vector<const char*> gradients;

    /// Convert this instance of `CalculationOptions` to a
    /// `featomic_calculation_options_t`.
    ///
    /// This is an advanced function that most users don't need to call
    /// directly.
    featomic_calculation_options_t as_featomic_calculation_options_t() {
        auto options = featomic_calculation_options_t{};
        std::memset(&options, 0, sizeof(featomic_calculation_options_t));

        options.use_native_system = this->use_native_system;

        options.gradients = this->gradients.data();
        options.gradients_count = this->gradients.size();

        options.selected_samples = this->selected_samples.as_featomic_labels_selection_t();
        options.selected_properties = this->selected_properties.as_featomic_labels_selection_t();

        if (this->selected_keys) {
            // store the raw mts_labels_t in a class variable to make sure
            // it lives longer than this function
            this->raw_selected_keys_ = this->selected_keys->as_mts_labels_t();
            options.selected_keys = &this->raw_selected_keys_;
        }

        return options;
    }

private:
    mts_labels_t raw_selected_keys_;
};


/// The `Calculator` class implements the calculation of a given atomic scale
/// representation. Specific implementation are registered globally, and
/// requested at construction.
class Calculator {
public:
    /// Create a new calculator with the given `name` and `parameters`.
    ///
    /// @throws FeatomicError if `name` is not associated with a known calculator,
    ///         if `parameters` is not valid JSON, or if `parameters` do not
    ///         contains the expected values for the requested calculator.
    ///
    /// @verbatim embed:rst:leading-slashes
    /// The list of available calculators and the corresponding parameters are
    /// in the :ref:`main documentation <userdoc-references>`. The ``parameters``
    /// should be formatted as JSON, according to the requested calculator
    /// schema.
    /// @endverbatim
    Calculator(std::string name, std::string parameters):
        calculator_(featomic_calculator(name.data(), parameters.data()))
    {
        if (this->calculator_ == nullptr) {
            throw FeatomicError(featomic_last_error());
        }
    }

    ~Calculator() {
        featomic_calculator_free(this->calculator_);
    }

    /// Calculator is **NOT** copy-constructible
    Calculator(const Calculator&) = delete;
    /// Calculator can **NOT** be copy-assigned
    Calculator& operator=(const Calculator&) = delete;

    /// Calculator is move-constructible
    Calculator(Calculator&& other) noexcept {
        *this = std::move(other);
    }

    /// Calculator can be move-assigned
    Calculator& operator=(Calculator&& other) noexcept {
        this->~Calculator();
        this->calculator_ = nullptr;

        std::swap(this->calculator_, other.calculator_);

        return *this;
    }

    /// Get the name used to create this `Calculator`
    std::string name() const {
        auto buffer = std::vector<char>(32, '\0');
        while (true) {
            auto status = featomic_calculator_name(
                calculator_, buffer.data(), buffer.size()
            );

            if (status != FEATOMIC_BUFFER_SIZE_ERROR) {
                details::check_status(status);
                return std::string(buffer.data());
            }

            // grow the buffer and retry
            buffer.resize(buffer.size() * 2, '\0');
        }
    }

    /// Get the parameters used to create this `Calculator`
    std::string parameters() const {
        auto buffer = std::vector<char>(256, '\0');
        while (true) {
            auto status = featomic_calculator_parameters(
                calculator_, buffer.data(), buffer.size()
            );

            if (status != FEATOMIC_BUFFER_SIZE_ERROR) {
                details::check_status(status);
                return std::string(buffer.data());
            }

            // grow the buffer and retry
            buffer.resize(buffer.size() * 2, '\0');
        }
    }

    /// Get all radial cutoffs used by this `Calculator`'s neighbors lists
    std::vector<double> cutoffs() const {
        const double* data = nullptr;
        uintptr_t length = 0;
        details::check_status(featomic_calculator_cutoffs(
            calculator_,
            &data,
            &length
        ));
        return std::vector<double>(data, data + length);
    }

    /// Runs a calculation with this calculator on the given ``systems``
    metatensor::TensorMap compute(
        std::vector<featomic_system_t>& systems,
        CalculationOptions options = CalculationOptions()
    ) const {
        mts_tensormap_t* descriptor = nullptr;

        details::check_status(featomic_calculator_compute(
            calculator_,
            &descriptor,
            systems.data(),
            systems.size(),
            options.as_featomic_calculation_options_t()
        ));

        return metatensor::TensorMap(descriptor);
    }

    /// Runs a calculation for multiple `systems`
    template<typename SystemImpl, typename std::enable_if<std::is_base_of<System, SystemImpl>::value, bool>::type = true>
    metatensor::TensorMap compute(
        std::vector<SystemImpl>& systems,
        CalculationOptions options = CalculationOptions()
    ) const {
        auto featomic_systems = std::vector<featomic_system_t>();
        for (auto& system: systems) {
            featomic_systems.push_back(system.as_featomic_system_t());
        }

        return this->compute(featomic_systems, std::move(options));
    }

    /// Runs a calculation for a single `system`
    template<typename SystemImpl, typename std::enable_if<std::is_base_of<System, SystemImpl>::value, bool>::type = true>
    metatensor::TensorMap compute(
        SystemImpl& system,
        CalculationOptions options = CalculationOptions()
    ) const {
        mts_tensormap_t* descriptor = nullptr;

        auto featomic_system = system.as_featomic_system_t();
        details::check_status(featomic_calculator_compute(
            calculator_,
            &descriptor,
            &featomic_system,
            1,
            options.as_featomic_calculation_options_t()
        ));

        return metatensor::TensorMap(descriptor);
    }

    /// Get the underlying pointer to a `featomic_calculator_t`.
    ///
    /// This is an advanced function that most users don't need to call
    /// directly.
    featomic_calculator_t* as_featomic_calculator_t() {
        return calculator_;
    }

    /// Get the underlying const pointer to a `featomic_calculator_t`.
    ///
    /// This is an advanced function that most users don't need to call
    /// directly.
    const featomic_calculator_t* as_featomic_calculator_t() const {
        return calculator_;
    }

private:
    featomic_calculator_t* calculator_ = nullptr;
};


/// Featomic uses the [`time_graph`](https://docs.rs/time-graph/) to collect
/// timing information on the calculations. The `Profiler` static class provides
/// access to this functionality.
///
/// The profiling code collects the total time spent inside the most important
/// functions, as well as the function call graph (which function called which
/// other function).
class Profiler {
public:
    Profiler() = delete;

    /// Enable or disable profiling data collection. By default, data collection
    /// is disabled.
    ///
    /// You can use `Profiler::clear` to reset profiling data to an empty state,
    /// and `Profiler::get` to extract the profiling data.
    ///
    /// @param enabled whether data collection should be enabled or not
    static void enable(bool enabled) {
        details::check_status(featomic_profiling_enable(enabled));
    }

    /// Clear all collected profiling data
    ///
    /// See also `Profiler::enable` and `Profiler::get`.
    static void clear() {
        details::check_status(featomic_profiling_clear());
    }

    /// Extract the current set of data collected for profiling.
    ///
    /// See also `Profiler::enable` and `Profiler::clear`.
    ///
    /// @param format in which format should the data be provided. `"table"`,
    ///              `"short_table"` and `"json"` are currently supported
    /// @returns the current profiling data, in the requested format
    static std::string get(const std::string& format) {
        auto buffer = std::vector<char>(1024, '\0');
        while (true) {
            auto status = featomic_profiling_get(
                format.c_str(), buffer.data(), buffer.size()
            );

            if (status != FEATOMIC_BUFFER_SIZE_ERROR) {
                details::check_status(status);
                return std::string(buffer.data());
            }

            // grow the buffer and retry
            buffer.resize(buffer.size() * 2, '\0');
        }
    }
};

}

#endif
