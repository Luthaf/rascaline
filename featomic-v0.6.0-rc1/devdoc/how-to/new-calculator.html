<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="Profiling calculation" href="profiling.html" /><link rel="prev" title="How-to guides" href="index.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.08.06 -->
        <title>Adding a new calculator - Featomic 0.6.0-rc1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../_static/featomic.css?v=191cc0c0" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/fontawesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/solid.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/brands.min.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Featomic 0.6.0-rc1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Featomic 0.6.0-rc1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../get-started/index.html">Getting started</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Getting started</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../get-started/featomic.html">What is featomic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../get-started/installation.html">Installation</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../get-started/tutorials.html">Tutorials: using featomic from Python</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Tutorials: using featomic from Python</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../examples/first-calculation.html">First descriptor computation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../how-to/index.html">How-to guides</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of How-to guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../how-to/computing-soap.html">Computing SOAP features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../how-to/sample-selection.html">Sample Selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../how-to/property-selection.html">Property Selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../how-to/keys-selection.html">Keys selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../how-to/splined-radial-integral.html">Splined radial integral</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../how-to/long-range.html">Long-range only LODE descriptor</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../references/index.html">Reference guides</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Reference guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../references/calculators/index.html">Calculator reference</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Calculator reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../references/calculators/spherical-expansion.html">Spherical expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../references/calculators/spherical-expansion-by-pair.html">Spherical expansion by pair</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../references/calculators/lode-spherical-expansion.html">LODE spherical expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../references/calculators/soap-radial-spectrum.html">SOAP radial spectrum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../references/calculators/soap-power-spectrum.html">SOAP power spectrum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../references/calculators/atomic-composition.html">Atomic Composition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../references/calculators/neighbor-list.html">Neighbor List</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../references/calculators/sorted-distances.html">Sorted distance vector</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../references/api/index.html">API documentation</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of API documentation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../references/api/python/index.html">Python</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Python</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/python/systems.html">Available system implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/python/calculators.html">Available Calculators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/python/misc.html">Miscellaneous</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/python/cutoff.html">Local environments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/python/density.html">Atomic density</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/python/basis.html">Basis functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/python/splines.html">Splined radial integrals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/python/clebsch-gordan.html">Clebsch-Gordan products</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../references/api/torch/index.html">TorchScript</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of TorchScript</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/torch/systems.html">System</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/torch/calculators.html">Calculators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/torch/clebsch-gordan.html">Clebsch-Gordan products</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../../references/api/torch/cxx/index.html">TorchScript C++ API reference</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of TorchScript C++ API reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../../references/api/torch/cxx/calculators.html">Calculators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../references/api/rust.html">Rust</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../references/api/c/index.html">C</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of C</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/c/systems.html">Defining systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/c/calculators.html">Dealing with calculators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/c/misc.html">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../references/api/cxx/index.html">C++</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of C++</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/cxx/systems.html">Defining systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/cxx/calculators.html">Dealing with calculators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../references/api/cxx/misc.html">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../explanations/index.html">Explanations</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of Explanations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../explanations/concepts.html">Core concepts of featomic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../explanations/soap.html">What is SOAP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../explanations/rotation_adapted.html">Rotation-Adapted Features</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../index.html">Developer documentation</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle navigation of Developer documentation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../get-started.html">Getting started</a></li>
<li class="toctree-l2 current has-children"><a class="reference internal" href="index.html">How-to guides</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle navigation of How-to guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l3 current current-page"><a class="current reference internal" href="#">Adding a new calculator</a></li>
<li class="toctree-l3"><a class="reference internal" href="profiling.html">Profiling calculation</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../explanations/index.html">Explanations</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle navigation of Explanations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../explanations/architecture.html">Code organization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../explanations/interfaces.html">Python and C interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../explanations/radial-integral.html">SOAP and LODE radial integrals</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../../_sources/devdoc/how-to/new-calculator.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="adding-a-new-calculator">
<h1>Adding a new calculator<a class="headerlink" href="#adding-a-new-calculator" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Before adding a new calculator it be might worth taking a look if your desired already
exists in our <a class="reference internal" href="../../references/calculators/index.html#userdoc-calculators"><span class="std std-ref">list</span></a> supported ones.</p>
<p>In this tutorial, we will go over all the steps required to create a new
calculator. For simplicity sake, the calculator we will implement will be very
basic, keeping the focus on how different bits of the code interact with one
another instead of complex math or performance tricks.</p>
<p>The calculator that we will create computes an atom-centered representation,
where each atomic environment is represented with the moments of the positions
of the neighbors up to a maximal order. Each atomic type in the neighborhood
will be considered separately. The resulting descriptor will represent an
atom-centered environment <span class="math notranslate nohighlight">\(\ket{\mathcal{A}_i}\)</span> on a basis of atomic types
<span class="math notranslate nohighlight">\(\alpha\)</span> and moment order <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\braket{\alpha k | \mathcal{A}_i} = \frac{1}{N_\text{neighbors}} \sum_{j \in \mathcal{A}_i} r_{ij}^k \ \delta_{\alpha, \alpha_j}\]</div>
</div>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/moments-descriptor.svg"><img alt="../../_images/moments-descriptor.svg" src="../../_images/moments-descriptor.svg" width="40%" /></a>
</figure>
<p>Throughout this tutorial, very basic knowledge of the Rust and Python
programming languages is assumed. If you are just starting up, you may find the
official <a class="reference external" href="https://doc.rust-lang.org/stable/book/">Rust book</a> useful; as well
as the documentation for the <a class="reference external" href="https://doc.rust-lang.org/stable/std/">standard library</a>; and the <a class="reference external" href="../reference/rust/featomic/index.html">API documentation</a> for
featomic itself.</p>
<p>We will also assume that you have a local copy of the featomic git repository,
and can build the code and run the tests. If not, please look at the
<a class="reference internal" href="../get-started.html#devdoc-get-started"><span class="std std-ref">Getting started</span></a> sections.</p>
</section>
<section id="the-traits-we-ll-use">
<h2>The traits we’ll use<a class="headerlink" href="#the-traits-we-ll-use" title="Link to this heading">¶</a></h2>
<p>Two of the three <a class="reference internal" href="../../explanations/concepts.html#core-concepts"><span class="std std-ref">core concepts</span></a> in featomic are
represented in the code as Rust traits: systems implements the <a class="reference external" href="../reference/rust/featomic/systems/trait.System.html">System</a> trait,
and calculators implement the <a class="reference external" href="../reference/rust/featomic/calculators/trait.CalculatorBase.html">CalculatorBase</a> trait. Traits (also called
interfaces in other languages) define contracts that the implementing code must
follow, in the form of a set of function and documented behavior for these
functions. Fulfilling this contract allow to add new systems which work with all
calculators, already implement or not; and new calculators which can use any
system, already implemented or not.</p>
<p>In this tutorial, our goal is to write a new struct implementing
<a class="reference external" href="../reference/rust/featomic/calculators/trait.CalculatorBase.html">CalculatorBase</a>. This implementation will take as input a slice of boxed
<a class="reference external" href="../reference/rust/featomic/systems/trait.System.html">System</a> trait objects, and using data from those fill up a <a class="reference external" href="../reference/rust/metatensor/tensor/struct.TensorMap.html">TensorMap</a>
(defined in the metatensor crate).</p>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h2>
<p>Let’s start by creating a new file in <code class="docutils literal notranslate"><span class="pre">featomic/src/calculators/moments.rs</span></code>,
and importing everything we’ll need. Everything in here will be explained when
we get to using it.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">metatensor</span><span class="p">::{</span><span class="n">Labels</span><span class="p">,</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">,</span><span class="w"> </span><span class="n">LabelsBuilder</span><span class="p">};</span>

<span class="k">use</span><span class="w"> </span><span class="k">crate</span><span class="p">::{</span><span class="n">System</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="p">};</span>
<span class="k">use</span><span class="w"> </span><span class="k">crate</span><span class="p">::</span><span class="n">labels</span><span class="p">::{</span><span class="n">CenterSingleNeighborsTypesKeys</span><span class="p">,</span><span class="w"> </span><span class="n">KeysBuilder</span><span class="p">};</span>
<span class="k">use</span><span class="w"> </span><span class="k">crate</span><span class="p">::</span><span class="n">labels</span><span class="p">::{</span><span class="n">AtomCenteredSamples</span><span class="p">,</span><span class="w"> </span><span class="n">SamplesBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">AtomicTypeFilter</span><span class="p">};</span>
<span class="k">use</span><span class="w"> </span><span class="k">crate</span><span class="p">::</span><span class="n">calculators</span><span class="p">::</span><span class="n">CalculatorBase</span><span class="p">;</span>
</pre></div>
</div>
<p>Then, we can define a struct for our new calculator <code class="docutils literal notranslate"><span class="pre">GeometricMoments</span></code>. It
will contain two fields: <code class="docutils literal notranslate"><span class="pre">cutoff</span></code> to store the cutoff radius, and
<code class="docutils literal notranslate"><span class="pre">max_moment</span></code> to store the maximal moment to compute.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[derive(Clone, Debug)]</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">GeometricMoments</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cutoff</span><span class="p">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span>
<span class="w">    </span><span class="n">max_moment</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can then write a skeleton implementation for the <a class="reference external" href="../reference/rust/featomic/calculators/trait.CalculatorBase.html">CalculatorBase</a> trait,
leaving all function unimplemented with the <code class="docutils literal notranslate"><span class="pre">todo!()</span></code> macro.
<code class="docutils literal notranslate"><span class="pre">CalculatorBase</span></code> is the trait defining all the functions required for a
calculator. Users might be more familiar with the concrete struct <a class="reference external" href="../reference/rust/featomic/struct.Calculator.html">Calculator</a>,
which uses a <code class="docutils literal notranslate"><span class="pre">Box&lt;dyn</span> <span class="pre">CalculatorBase&gt;</span></code> (i.e. a pointer to a
<code class="docutils literal notranslate"><span class="pre">CalculatorBase</span></code>) to provide its functionalities.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">CalculatorBase</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GeometricMoments</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">cutoffs</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">f64</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">keys</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Labels</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">sample_names</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">samples</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Labels</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Labels</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">supports_gradient</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">positions_gradient_samples</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Labels</span><span class="p">,</span><span class="w"> </span><span class="n">samples</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="n">Labels</span><span class="p">],</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Labels</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">components</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Labels</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Labels</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">property_names</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">properties</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Labels</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Labels</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We’ll go over these functions one by one, explaining what they do as we go. Most
of the functions here are used to communicate metadata about the calculator and
the representation, and the <code class="docutils literal notranslate"><span class="pre">compute</span></code> function does the main part of the work.</p>
<section id="calculator-metadata">
<h3>Calculator metadata<a class="headerlink" href="#calculator-metadata" title="Link to this heading">¶</a></h3>
<p>The first function returning metadata about the calculator itself is <code class="docutils literal notranslate"><span class="pre">name</span></code>,
which should return a user-facing name for the current instance of the
descriptor. As a quick refresher on Rust, all functions return the last (and in
this case only) expression. Here the expression creates a reference to a str
(<code class="docutils literal notranslate"><span class="pre">&amp;str</span></code>) and then convert it to an heap-allocated <code class="docutils literal notranslate"><span class="pre">String</span></code> using the <a class="reference external" href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into</a>
trait.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s">&quot;geometric moments&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, the <code class="docutils literal notranslate"><span class="pre">parameters</span></code> function should return the parameters used to
create the current instance of the calculator in JSON format. To this end, we
use <a class="reference external" href="https://serde.rs/">serde</a> and <code class="docutils literal notranslate"><span class="pre">serde_json</span></code> everywhere in featomic, so it is a good idea to
do the same here. Let’s start by adding the corresponding <code class="docutils literal notranslate"><span class="pre">#[derive]</span></code> to the
definition of <code class="docutils literal notranslate"><span class="pre">GeometricMoments</span></code>, and use it to implement the function.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[derive(Clone, Debug)]</span>
<span class="cp">#[derive(serde::Serialize, serde::Deserialize)]</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">GeometricMoments</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cutoff</span><span class="p">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span>
<span class="w">    </span><span class="n">max_moment</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">serde_json</span><span class="p">::</span><span class="n">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;failed to serialize to JSON&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One interesting thing here is that <code class="docutils literal notranslate"><span class="pre">serde_json::to_string</span></code> returns a
<code class="docutils literal notranslate"><span class="pre">Result&lt;String,</span> <span class="pre">serde::Error&gt;</span></code>, and we use <code class="docutils literal notranslate"><span class="pre">expect</span></code> to extract the string
value. This <a class="reference external" href="https://doc.rust-lang.org/std/result/index.html">Result</a> would only contain an error if <code class="docutils literal notranslate"><span class="pre">GeometricMoments</span></code>
contained maps with non-string keys, which is not the case here. <code class="docutils literal notranslate"><span class="pre">expect</span></code>
allow us to indicate we don’t ever expect this function to fail, but if it were
to return an error, then the code would immediately stop and show the given
message (using a <a class="reference external" href="https://doc.rust-lang.org/std/macro.panic.html">panic</a>).</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">cutoffs</span></code> function should return all the radial cutoffs used
in neighbors lists. Here, we only have one — <code class="docutils literal notranslate"><span class="pre">self.cutoffs</span></code> — and we use
<code class="docutils literal notranslate"><span class="pre">std::slice::from_ref</span></code> to construct a list with a single element from a
scalar.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">cutoffs</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">f64</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">::</span><span class="n">slice</span><span class="p">::</span><span class="n">from_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">cutoff</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="representation-metadata">
<h3>Representation metadata<a class="headerlink" href="#representation-metadata" title="Link to this heading">¶</a></h3>
<p>The next set of functions in the <a class="reference external" href="../reference/rust/featomic/calculators/trait.CalculatorBase.html">CalculatorBase</a> trait is used to communicate
metadata about the representation, and called by the concrete <a class="reference external" href="../reference/rust/featomic/struct.Calculator.html">Calculator</a>
struct when initializing and allocating the corresponding memory.</p>
<section id="keys">
<h4>Keys<a class="headerlink" href="#keys" title="Link to this heading">¶</a></h4>
<p>First, we have one function defining the set of keys that will be in the final
<code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>. In our case, we will want to have the central atom type and the
neighbor atom type as keys. This allow to only store data if a given neighbor
is actually present around a given atom.</p>
<p>We could manually create a set of <a class="reference external" href="../reference/rust/metatensor/labels/struct.Labels.html">Labels</a> with a <a class="reference external" href="../reference/rust/metatensor/labels/struct.LabelsBuilder.html">LabelsBuilder</a> and return
them. But since multiple calculators will create the same kind of keys, there
are already implementation of typical atomic types keys. Here we use
<code class="docutils literal notranslate"><span class="pre">CenterSingleNeighborsTypesKeys</span></code> to create a set of keys containing the
central atom type and one neighbor type. This key builder requires a <code class="docutils literal notranslate"><span class="pre">cutoff</span></code>
(to determine which neighbors it should use) and <code class="docutils literal notranslate"><span class="pre">self_pairs</span></code> indicated
whether atoms should be considered to be their own neighbor or not.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">keys</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Labels</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CenterSingleNeighborsTypesKeys</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cutoff</span><span class="p">:</span><span class="w"> </span><span class="nc">self</span><span class="p">.</span><span class="n">cutoff</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// self pairs would have a distance of 0 and would not contribute</span>
<span class="w">        </span><span class="c1">// anything meaningful to a GeometricMoments representation</span>
<span class="w">        </span><span class="n">self_pairs</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">keys</span><span class="p">(</span><span class="n">systems</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="samples">
<h4>Samples<a class="headerlink" href="#samples" title="Link to this heading">¶</a></h4>
<p>Having defined the keys, we need to define the metadata associated with each
block. For each block, the first set of metadata — called the <strong>samples</strong> –
describes the rows of the data. Three functions are used to define the samples:
first, <code class="docutils literal notranslate"><span class="pre">features_names</span></code> defines the name associated with the different columns
in the sample labels. Then, <code class="docutils literal notranslate"><span class="pre">samples</span></code> determines the set of samples associated
with each key/block. The return type of the <code class="docutils literal notranslate"><span class="pre">samples</span></code> function takes some
unpacking: we are returning a <a class="reference external" href="https://doc.rust-lang.org/std/result/index.html">Result</a> since any call to a <a class="reference external" href="../reference/rust/featomic/systems/trait.System.html">System</a> function
can fail. The non-error case of the result is a <code class="docutils literal notranslate"><span class="pre">Vec&lt;Labels&gt;</span></code>: we need
one set of <a class="reference external" href="../reference/rust/metatensor/labels/struct.Labels.html">Labels</a> for each key/block.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">sample_names</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">AtomCenteredSamples</span><span class="p">::</span><span class="n">sample_names</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">samples</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Labels</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Labels</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">names</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;center_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_type&quot;</span><span class="p">]);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">center_type</span><span class="p">,</span><span class="w"> </span><span class="n">neighbor_type</span><span class="p">]</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">keys</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AtomCenteredSamples</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cutoff</span><span class="p">:</span><span class="w"> </span><span class="nc">self</span><span class="p">.</span><span class="n">cutoff</span><span class="p">,</span>
<span class="w">            </span><span class="c1">// only include central atoms of this type</span>
<span class="w">            </span><span class="n">center_type</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicTypeFilter</span><span class="p">::</span><span class="n">Single</span><span class="p">(</span><span class="n">center_type</span><span class="p">.</span><span class="kt">i32</span><span class="p">()),</span>
<span class="w">            </span><span class="c1">// with a neighbor of this type somewhere in the neighborhood</span>
<span class="w">            </span><span class="c1">// defined by the spherical `cutoff`.</span>
<span class="w">            </span><span class="n">neighbor_type</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicTypeFilter</span><span class="p">::</span><span class="n">Single</span><span class="p">(</span><span class="n">neighbor_type</span><span class="p">.</span><span class="kt">i32</span><span class="p">()),</span>
<span class="w">            </span><span class="n">self_pairs</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">samples</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="n">systems</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">samples</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Like for <code class="docutils literal notranslate"><span class="pre">CalculatorBase::keys</span></code>, we could manually write code to detect the
right set of samples for each key. But since a lot of representation are built
on atom-centered neighborhoods, there is already a tool to create the right set
of samples in the form of <code class="docutils literal notranslate"><span class="pre">AtomCenteredSamples</span></code>.</p>
</section>
<section id="components">
<h4>Components<a class="headerlink" href="#components" title="Link to this heading">¶</a></h4>
<p>The next set of metadata associated with a block are the <strong>components</strong>. Each
block can have 0 or more components, that should be used to store metadata and
information about symmetry operations or any kind of tensorial components.</p>
<p>Here, we dont’ have any components (the <code class="docutils literal notranslate"><span class="pre">GeometricMoments</span></code> representation is
invariant), so we just return a list (one for each key) of empty vectors.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">components</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Labels</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Labels</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="fm">vec!</span><span class="p">[];</span><span class="w"> </span><span class="n">keys</span><span class="p">.</span><span class="n">count</span><span class="p">()];</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="properties">
<h4>Properties<a class="headerlink" href="#properties" title="Link to this heading">¶</a></h4>
<p>The <strong>properties</strong> define metadata associated with the columns of the data
arrays. Like for the samples, we have one function to define the set of names
associated with each variable in the properties <a class="reference external" href="../reference/rust/metatensor/labels/struct.Labels.html">Labels</a>, and one function to
compute the set of properties defined for each key.</p>
<p>In our case, there is only one variable in the properties labels, the power
<span class="math notranslate nohighlight">\(k\)</span> used to compute the moment. When building the full list of Labels for
each key in <code class="docutils literal notranslate"><span class="pre">CalculatorBase::properties</span></code>, we use the fact that the properties
are the same for each key/block and make copies of the <code class="docutils literal notranslate"><span class="pre">Labels</span></code> (since
<code class="docutils literal notranslate"><span class="pre">Labels</span></code> are reference-counted, the copies are actually quite cheap).</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">property_names</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&quot;k&quot;</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">properties</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Labels</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Labels</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LabelsBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">property_names</span><span class="p">());</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..=</span><span class="bp">self</span><span class="p">.</span><span class="n">max_moment</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">finish</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="n">properties</span><span class="p">;</span><span class="w"> </span><span class="n">keys</span><span class="p">.</span><span class="n">count</span><span class="p">()];</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="gradients">
<h4>Gradients<a class="headerlink" href="#gradients" title="Link to this heading">¶</a></h4>
<p>Finally, we have metadata related to the gradients. First, the
<code class="docutils literal notranslate"><span class="pre">supports_gradient</span></code> function should return which if any of the gradients can
be computed by the current calculator. Typically <code class="docutils literal notranslate"><span class="pre">parameter</span></code> is either
<code class="docutils literal notranslate"><span class="pre">&quot;positions&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;cell&quot;`</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;strain&quot;</span></code>. Here we only support computing
the gradients with respect to positions.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">supports_gradient</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s">&quot;positions&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the user request the calculation of some gradients, and the calculator
supports it, the next step is to define the same set of metadata as for the
values above: samples, components and properties. Properties are easy, because
they are the same between the values and the gradients. The components are also
similar, with some additional components added at the beginning depending on the
kind of gradient. For example, if a calculator uses <code class="docutils literal notranslate"><span class="pre">[first,</span> <span class="pre">second]</span></code> as it’s
set of components, the <code class="docutils literal notranslate"><span class="pre">&quot;positions&quot;</span></code> gradient would use <code class="docutils literal notranslate"><span class="pre">[xyz,</span> <span class="pre">first,</span>
<span class="pre">second]</span></code>, where <code class="docutils literal notranslate"><span class="pre">xyz</span></code> contains 3 entries. Similarly, the <code class="docutils literal notranslate"><span class="pre">&quot;strain&quot;</span></code>
gradients would use <code class="docutils literal notranslate"><span class="pre">[xyz_1,</span> <span class="pre">xyz_2,</span> <span class="pre">first,</span> <span class="pre">second]</span></code> and the <code class="docutils literal notranslate"><span class="pre">&quot;cell&quot;</span></code>
gradients would use <code class="docutils literal notranslate"><span class="pre">[abc,</span> <span class="pre">xyz,</span> <span class="pre">first,</span> <span class="pre">second]</span></code>.</p>
<p>Finally, the samples needs to be defined. For the <code class="docutils literal notranslate"><span class="pre">&quot;cell&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;strain&quot;</span></code>
gradients, there is always exactly one gradient sample per value sample. For the
<code class="docutils literal notranslate"><span class="pre">&quot;positions&quot;</span></code> gradient samples, we could have one gradient sample for each
atom in the same system for each value sample. However, this would create a very
large number of gradient samples (number of atoms squared), and a lot of entries
would be filled with zeros. Instead, each calculator which supports positions
gradients must implement the <code class="docutils literal notranslate"><span class="pre">positions_gradient_samples</span></code> function, and use it
to return only the sample associated with non-zero gradients. This function get
as input the set of keys, the list of samples associated with each key, and the
list of systems on which we want to run the calculation.</p>
<p>We are again using the <code class="docutils literal notranslate"><span class="pre">AtomCenteredSamples</span></code> here to share code between
multiple calculators all using atom-centered samples.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">positions_gradient_samples</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Labels</span><span class="p">,</span><span class="w"> </span><span class="n">samples</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="n">Labels</span><span class="p">],</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Labels</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">names</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;center_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_type&quot;</span><span class="p">]);</span>
<span class="w">    </span><span class="fm">debug_assert_eq!</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">count</span><span class="p">(),</span><span class="w"> </span><span class="n">samples</span><span class="p">.</span><span class="n">len</span><span class="p">());</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gradient_samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">center_type</span><span class="p">,</span><span class="w"> </span><span class="n">neighbor_type</span><span class="p">],</span><span class="w"> </span><span class="n">samples_for_key</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">keys</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">zip</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AtomCenteredSamples</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cutoff</span><span class="p">:</span><span class="w"> </span><span class="nc">self</span><span class="p">.</span><span class="n">cutoff</span><span class="p">,</span>
<span class="w">            </span><span class="n">center_type</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicTypeFilter</span><span class="p">::</span><span class="n">Single</span><span class="p">(</span><span class="n">center_type</span><span class="p">.</span><span class="kt">i32</span><span class="p">()),</span>
<span class="w">            </span><span class="c1">// only include gradients with respect to neighbor atoms with</span>
<span class="w">            </span><span class="c1">// this atomic type (the other atoms do not contribute to the</span>
<span class="w">            </span><span class="c1">// gradients in the current block).</span>
<span class="w">            </span><span class="n">neighbor_type</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicTypeFilter</span><span class="p">::</span><span class="n">Single</span><span class="p">(</span><span class="n">neighbor_type</span><span class="p">.</span><span class="kt">i32</span><span class="p">()),</span>
<span class="w">            </span><span class="n">self_pairs</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">gradient_samples</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">gradients_for</span><span class="p">(</span><span class="n">systems</span><span class="p">,</span><span class="w"> </span><span class="n">samples_for_key</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">gradient_samples</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We are now done defining the metadata associated with our <code class="docutils literal notranslate"><span class="pre">GeometricMoments</span></code>
calculator! In the next section, we’ll go over the actual calculation of the
representation, and how to use the functions provided by <a class="reference external" href="../reference/rust/featomic/systems/trait.System.html">System</a>.</p>
</section>
</section>
<section id="the-compute-function">
<h3>The compute function<a class="headerlink" href="#the-compute-function" title="Link to this heading">¶</a></h3>
<p>We are finally approaching the most important function in <a class="reference external" href="../reference/rust/featomic/calculators/trait.CalculatorBase.html">CalculatorBase</a>,
<code class="docutils literal notranslate"><span class="pre">compute</span></code>. This function takes as input a list of systems and a <a class="reference external" href="../reference/rust/metatensor/tensor/struct.TensorMap.html">TensorMap</a>
in which to write the results of the calculation. The function also returns a
<a class="reference external" href="https://doc.rust-lang.org/std/result/index.html">Result</a>, to be able to indicate that an error was reached during the
calculation.</p>
<p>The <a class="reference external" href="../reference/rust/metatensor/tensor/struct.TensorMap.html">TensorMap</a> is initialized by the concrete <a class="reference external" href="../reference/rust/featomic/struct.Calculator.html">Calculator</a> struct, according
to parameters provided by the user. In particular, the tensor map will only
contain samples and properties requested by the user, meaning that the code in
<code class="docutils literal notranslate"><span class="pre">compute</span></code> should check for each block whether a particular sample
(respectively property) is present in <code class="docutils literal notranslate"><span class="pre">block.samples</span></code> (resp.
<code class="docutils literal notranslate"><span class="pre">block.property</span></code>) before computing it.</p>
<p>This being said, let’s start writing our <code class="docutils literal notranslate"><span class="pre">compute</span></code> function. We’ll defensively
check that the tensor map keys match what we expect from them, and return a unit
value <code class="docutils literal notranslate"><span class="pre">()</span></code> wrapped in <code class="docutils literal notranslate"><span class="pre">Ok</span></code> at the end of the function.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">names</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;center_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_type&quot;</span><span class="p">]);</span>

<span class="w">    </span><span class="c1">// we&#39;ll add more code here</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>From here, the easiest way to implement our geometric moments descriptor is to
iterate over the systems, and then iterate over the pairs in the system. Before
we can get the pairs with <code class="docutils literal notranslate"><span class="pre">system.pairs()</span></code>, we need to compute the neighbors
list for our current cutoff, using <code class="docutils literal notranslate"><span class="pre">system.compute_neighbors()</span></code>, which
requires a mutable reference to the system to be able to store the list of
computed pairs (hence the iteration using <code class="docutils literal notranslate"><span class="pre">systems.iter_mut()</span></code>).</p>
<p>All the functions on the <a class="reference external" href="../reference/rust/featomic/systems/trait.System.html">System</a> trait return <a class="reference external" href="https://doc.rust-lang.org/std/result/index.html">Result</a>, but in contrary to
the <code class="docutils literal notranslate"><span class="pre">CalculatorBase::parameters</span></code> function above, we want to send the possible
errors back to the user so that they can deal with them as they want. The
question mark <code class="docutils literal notranslate"><span class="pre">?</span></code> operator does exactly that: if the value returned by the
called function is <code class="docutils literal notranslate"><span class="pre">Err(e)</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code> immediately returns <code class="docutils literal notranslate"><span class="pre">Err(e)</span></code>; and if the
result is <code class="docutils literal notranslate"><span class="pre">Ok(v)</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code> extract the <code class="docutils literal notranslate"><span class="pre">v</span></code> and the execution continues.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">names</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;center_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_type&quot;</span><span class="p">]);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">system_i</span><span class="p">,</span><span class="w"> </span><span class="n">system</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">systems</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">system</span><span class="p">.</span><span class="n">compute_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">cutoff</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs</span><span class="p">()</span><span class="o">?</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// more code to come here</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For each pair, we now have to find the corresponding block (using the center and
neighbor atomic types), and check wether the corresponding sample was
requested by the user.</p>
<p>To find blocks and check for samples, we can use the <a class="reference external" href="../reference/rust/metatensor/labels/struct.Labels.html#method.position">Labels::position</a>
function on the keys and the samples <a class="reference external" href="../reference/rust/metatensor/labels/struct.Labels.html">Labels</a>. This function returns an
<code class="docutils literal notranslate"><span class="pre">Option&lt;usize&gt;</span></code>, which will be <code class="docutils literal notranslate"><span class="pre">None</span></code> is the label (key or sample) was not
found, and <code class="docutils literal notranslate"><span class="pre">Some(position)</span></code> where <code class="docutils literal notranslate"><span class="pre">position</span></code> is an unsigned integer if the
label was found. For the keys, we know the blocks must exists, so we again use
<code class="docutils literal notranslate"><span class="pre">expect</span></code> to immediately extract the value of the block index and access the
block. For the samples, we keep them as <code class="docutils literal notranslate"><span class="pre">Option&lt;usize&gt;</span></code> and will deal with
missing samples later.</p>
<p>One thing to keep in mind is that a given pair can participate to two different
samples. If two atoms <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> are closer than the cutoff, the list of
pairs will only contain the <code class="docutils literal notranslate"><span class="pre">i-j</span></code> pair, and not the <code class="docutils literal notranslate"><span class="pre">j-i</span></code> pair (it is a
so-called half neighbors list). That being said, we can get the list of atomic types
with <code class="docutils literal notranslate"><span class="pre">system.types()</span></code> before the loop over pairs, and then construct the two
candidate samples and check for their presence. If neither of the samples was
requested, then we can skip the calculation for this pair. We also use
<code class="docutils literal notranslate"><span class="pre">system.pairs_containing()</span></code> to get the number of neighbors a given center has.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">names</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;center_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_type&quot;</span><span class="p">]);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">system_i</span><span class="p">,</span><span class="w"> </span><span class="n">system</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">systems</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">system</span><span class="p">.</span><span class="n">compute_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">cutoff</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// add this line</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">types</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs</span><span class="p">()</span><span class="o">?</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// get the block where the first atom is the center</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">first_block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                </span><span class="n">types</span><span class="p">[</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">types</span><span class="p">[</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">into</span><span class="p">(),</span>
<span class="w">            </span><span class="p">]);</span>

<span class="w">            </span><span class="c1">// get the sample corresponding to the first atom as a center</span>
<span class="w">            </span><span class="c1">//</span>
<span class="w">            </span><span class="c1">// This will be `None` if the block or samples are not present</span>
<span class="w">            </span><span class="c1">// in the descriptor, i.e. if the user did not request them.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">first_sample_position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_block_id</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">).</span><span class="n">samples</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                    </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                </span><span class="p">])</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nb">None</span>
<span class="w">            </span><span class="p">};</span>

<span class="w">            </span><span class="c1">// get the id of the block where the second atom is the center</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">second_block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                </span><span class="n">types</span><span class="p">[</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">types</span><span class="p">[</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">into</span><span class="p">(),</span>
<span class="w">            </span><span class="p">]);</span>
<span class="w">            </span><span class="c1">// get the sample corresponding to the first atom as a center</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">second_sample_position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_block_id</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">).</span><span class="n">samples</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                    </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                </span><span class="p">])</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nb">None</span>
<span class="w">            </span><span class="p">};</span>

<span class="w">            </span><span class="c1">// skip calculation if neither of the samples is present</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">first_sample_position</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">second_sample_position</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs_containing</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs_containing</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// more code coming up here!</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, we can check if the samples are present, and if they are, iterate over the
requested features, compute the moments for the current pair distance, and
accumulate it in the descriptor values array:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">system_i</span><span class="p">,</span><span class="w"> </span><span class="n">system</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">systems</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs</span><span class="p">()</span><span class="o">?</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// ...</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs_containing</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs_containing</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_sample_position</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_block_id</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;we have a sample in this block&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_mut_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">data_mut</span><span class="p">();</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">to_array_mut</span><span class="p">();</span>

<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">property_i</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="kt">i32</span><span class="p">())</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                    </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_sample_position</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_block_id</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;we have a sample in this block&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_mut_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">data_mut</span><span class="p">();</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">to_array_mut</span><span class="p">();</span>

<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">property_i</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="kt">i32</span><span class="p">())</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                    </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// more code coming up</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we can deal with the gradients. We first check if gradient data is
defined in the descriptor we need to fill, by checking if it is defined on the
first block (we know it is either defined on all blocks or none).</p>
<p>If we need to compute the gradients with respect to atomic positions, we will us
the following expression:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial \vec{r_{j}}} \braket{\alpha k | \chi_i}
= \frac{\vec{r_{ij}}}{r_{ij}} \cdot \frac{k \ r_{ij}^{k - 1} \ \delta_{\alpha, \alpha_j}}{N_\text{neighbors}}
= \vec{r_{ij}} \frac{k \ r_{ij}^{k - 2} \ \delta_{\alpha, \alpha_j}}{N_\text{neighbors}}\]</div>
</div>
<p>The code to compute gradients is very similar to the code computing the
representation, checking the existence of a given gradient sample before writing
to it. There are now four possible contributions for a given pair:
<span class="math notranslate nohighlight">\(\partial \ket{\chi_i} / \partial r_j\)</span>, <span class="math notranslate nohighlight">\(\partial \ket{\chi_j} /
\partial r_i\)</span>, <span class="math notranslate nohighlight">\(\partial \ket{\chi_i} / \partial r_i\)</span> and <span class="math notranslate nohighlight">\(\partial
\ket{\chi_j} / \partial r_j\)</span>, where <span class="math notranslate nohighlight">\(\ket{\chi_i}\)</span> is the representation
around atom <span class="math notranslate nohighlight">\(i\)</span>. Another way to say it is that in addition to the
gradients of the descriptor centered on <span class="math notranslate nohighlight">\(i\)</span> with respect to atom
<span class="math notranslate nohighlight">\(j\)</span>, we also need to account for the gradient of the descriptor centered
on atom <span class="math notranslate nohighlight">\(i\)</span> with respect to its own position.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// add these lines</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">do_positions_gradients</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">gradient</span><span class="p">(</span><span class="s">&quot;positions&quot;</span><span class="p">).</span><span class="n">is_some</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">system_i</span><span class="p">,</span><span class="w"> </span><span class="n">system</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">systems</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs</span><span class="p">()</span><span class="o">?</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// ...</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">do_positions_gradients</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">moment_gradients</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..=</span><span class="bp">self</span><span class="p">.</span><span class="n">max_moment</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">moment_gradients</span><span class="p">.</span><span class="n">push</span><span class="p">([</span>
<span class="w">                        </span><span class="n">pair</span><span class="p">.</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
<span class="w">                        </span><span class="n">pair</span><span class="p">.</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
<span class="w">                        </span><span class="n">pair</span><span class="p">.</span><span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
<span class="w">                    </span><span class="p">]);</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_position</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_sample_position</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_block_id</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;we have a sample in this block&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_mut_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">);</span>

<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">gradient_mut</span><span class="p">(</span><span class="s">&quot;positions&quot;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;missing gradient storage&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">data_mut</span><span class="p">();</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">to_array_mut</span><span class="p">();</span>

<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient_wrt_second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                        </span><span class="n">sample_position</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                    </span><span class="p">]);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient_wrt_self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                        </span><span class="n">sample_position</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                    </span><span class="p">]);</span>

<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">property_i</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient_wrt_second</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moment_gradients</span><span class="p">[</span><span class="n">k</span><span class="p">.</span><span class="kt">usize</span><span class="p">()];</span>
<span class="w">                            </span><span class="c1">// There is one extra dimension in the gradients</span>
<span class="w">                            </span><span class="c1">// array compared to the values, accounting for</span>
<span class="w">                            </span><span class="c1">// each of the Cartesian directions.</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient_wrt_self</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moment_gradients</span><span class="p">[</span><span class="n">k</span><span class="p">.</span><span class="kt">usize</span><span class="p">()];</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_position</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_sample_position</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_block_id</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;we have a sample in this block&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_mut_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">);</span>

<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">gradient_mut</span><span class="p">(</span><span class="s">&quot;positions&quot;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;missing gradient storage&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">data_mut</span><span class="p">();</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">to_array_mut</span><span class="p">();</span>

<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient_wrt_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                        </span><span class="n">sample_position</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                    </span><span class="p">]);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient_wrt_self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                        </span><span class="n">sample_position</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                    </span><span class="p">]);</span>

<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">property_i</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient_wrt_first</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moment_gradients</span><span class="p">[</span><span class="n">k</span><span class="p">.</span><span class="kt">usize</span><span class="p">()];</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient_wrt_self</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moment_gradients</span><span class="p">[</span><span class="n">k</span><span class="p">.</span><span class="kt">usize</span><span class="p">()];</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(());</span>
<span class="p">}</span>
</pre></div>
</div>
<hr class="docutils" />
<details><summary><a>Here is the final implementation for the compute function</a></summary><div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">systems</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">System</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">names</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;center_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_type&quot;</span><span class="p">]);</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">do_positions_gradients</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">gradient</span><span class="p">(</span><span class="s">&quot;positions&quot;</span><span class="p">).</span><span class="n">is_some</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">system_i</span><span class="p">,</span><span class="w"> </span><span class="n">system</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">systems</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">system</span><span class="p">.</span><span class="n">compute_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">cutoff</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">types</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs</span><span class="p">()</span><span class="o">?</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">first_block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                </span><span class="n">types</span><span class="p">[</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">types</span><span class="p">[</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">into</span><span class="p">(),</span>
<span class="w">            </span><span class="p">]);</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">first_sample_position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_block_id</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">).</span><span class="n">samples</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                    </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                </span><span class="p">])</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nb">None</span>
<span class="w">            </span><span class="p">};</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">second_block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                </span><span class="n">types</span><span class="p">[</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">types</span><span class="p">[</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">into</span><span class="p">(),</span>
<span class="w">            </span><span class="p">]);</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">second_sample_position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_block_id</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">).</span><span class="n">samples</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                    </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                </span><span class="p">])</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nb">None</span>
<span class="w">            </span><span class="p">};</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">first_sample_position</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">second_sample_position</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs_containing</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">pairs_containing</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_sample_position</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_block_id</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;we have a sample in this block&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_mut_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">data_mut</span><span class="p">();</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">to_array_mut</span><span class="p">();</span>

<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">property_i</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="kt">i32</span><span class="p">())</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                    </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_sample_position</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_block_id</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;we have a sample in this block&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_mut_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">data_mut</span><span class="p">();</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">to_array_mut</span><span class="p">();</span>

<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">property_i</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="kt">i32</span><span class="p">())</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                    </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">do_positions_gradients</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">moment_gradients</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..=</span><span class="bp">self</span><span class="p">.</span><span class="n">max_moment</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">moment_gradients</span><span class="p">.</span><span class="n">push</span><span class="p">([</span>
<span class="w">                        </span><span class="n">pair</span><span class="p">.</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
<span class="w">                        </span><span class="n">pair</span><span class="p">.</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
<span class="w">                        </span><span class="n">pair</span><span class="p">.</span><span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">f64</span><span class="p">::</span><span class="n">powi</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
<span class="w">                    </span><span class="p">]);</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_position</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_sample_position</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_block_id</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;we have a sample in this block&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_mut_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">);</span>

<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">gradient_mut</span><span class="p">(</span><span class="s">&quot;positions&quot;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;missing gradient storage&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">data_mut</span><span class="p">();</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">to_array_mut</span><span class="p">();</span>

<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient_wrt_second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                        </span><span class="n">sample_position</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                    </span><span class="p">]);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient_wrt_self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                        </span><span class="n">sample_position</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                    </span><span class="p">]);</span>

<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">property_i</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient_wrt_second</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moment_gradients</span><span class="p">[</span><span class="n">k</span><span class="p">.</span><span class="kt">usize</span><span class="p">()];</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient_wrt_self</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moment_gradients</span><span class="p">[</span><span class="n">k</span><span class="p">.</span><span class="kt">usize</span><span class="p">()];</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_first</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_position</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_sample_position</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">second_block_id</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;we have a sample in this block&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_mut_by_id</span><span class="p">(</span><span class="n">block_id</span><span class="p">);</span>

<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">gradient_mut</span><span class="p">(</span><span class="s">&quot;positions&quot;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;missing gradient storage&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">data_mut</span><span class="p">();</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">to_array_mut</span><span class="p">();</span>

<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient_wrt_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                        </span><span class="n">sample_position</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                    </span><span class="p">]);</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">gradient_wrt_self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">position</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span>
<span class="w">                        </span><span class="n">sample_position</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">system_i</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">into</span><span class="p">()</span>
<span class="w">                    </span><span class="p">]);</span>

<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">property_i</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">gradient</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">iter_fixed_size</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient_wrt_first</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moment_gradients</span><span class="p">[</span><span class="n">k</span><span class="p">.</span><span class="kt">usize</span><span class="p">()];</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">sample_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gradient_wrt_self</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moment_gradients</span><span class="p">[</span><span class="n">k</span><span class="p">.</span><span class="kt">usize</span><span class="p">()];</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                            </span><span class="n">array</span><span class="p">[[</span><span class="n">sample_i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">property_i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_neighbors_second</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(());</span>
<span class="p">}</span>
</pre></div>
</div>
</details></section>
<section id="registering-the-new-calculator">
<h3>Registering the new calculator<a class="headerlink" href="#registering-the-new-calculator" title="Link to this heading">¶</a></h3>
<p>Now that we are done with the code for this calculator, we need to make it
available to users. The entry point for users is the <a class="reference external" href="../reference/rust/featomic/struct.Calculator.html">Calculator</a> struct, which
needs to be constructed from a calculator name and hyper-parameters in JSON
format.</p>
<p>When the user calls <code class="docutils literal notranslate"><span class="pre">Calculator::new(&quot;calculator_name&quot;,</span> <span class="pre">&quot;{\&quot;hyper_parameters\&quot;:</span>
<span class="pre">1}&quot;)</span></code>, featomic looks for <code class="docutils literal notranslate"><span class="pre">&quot;calculator_name&quot;</span></code> in the global calculator
registry, and tries to create an instance using the hyper-parameters. In order
to make our calculator available to all users, we need to add it to this
registry, in <code class="docutils literal notranslate"><span class="pre">featomic/src/calculator.rs</span></code>. The registry looks like this:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">REGISTERED_CALCULATORS</span><span class="p">:</span><span class="w"> </span><span class="nc">Lazy</span><span class="o">&lt;</span><span class="n">BTreeMap</span><span class="o">&lt;&amp;&#39;</span><span class="nb">static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">CalculatorCreator</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Lazy</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTreeMap</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atomic_composition&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">AtomicComposition</span><span class="p">);</span>
<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dummy_calculator&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DummyCalculator</span><span class="p">);</span>
<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_list&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NeighborList</span><span class="p">);</span>
<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;sorted_distances&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SortedDistances</span><span class="p">);</span>

<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spherical_expansion_by_pair&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SphericalExpansionByPair</span><span class="p">,</span><span class="w"> </span><span class="n">SphericalExpansionParameters</span><span class="p">);</span>
<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spherical_expansion&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SphericalExpansion</span><span class="p">,</span><span class="w"> </span><span class="n">SphericalExpansionParameters</span><span class="p">);</span>
<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;soap_radial_spectrum&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SoapRadialSpectrum</span><span class="p">,</span><span class="w"> </span><span class="n">RadialSpectrumParameters</span><span class="p">);</span>
<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;soap_power_spectrum&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SoapPowerSpectrum</span><span class="p">,</span><span class="w"> </span><span class="n">PowerSpectrumParameters</span><span class="p">);</span>

<span class="w">    </span><span class="n">add_calculator</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lode_spherical_expansion&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">LodeSphericalExpansion</span><span class="p">,</span><span class="w"> </span><span class="n">LodeSphericalExpansionParameters</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">map</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">add_calculator!</span></code> is a local macro that takes three or four arguments: the
registry itself (a <code class="docutils literal notranslate"><span class="pre">BTreeMap</span></code>), the calculator name, the struct implementing
<a class="reference external" href="../reference/rust/featomic/calculators/trait.CalculatorBase.html">CalculatorBase</a> and optionally a struct to use as parameters to create the
previous one. In our case, we want to use the three arguments version in
something like <code class="docutils literal notranslate"><span class="pre">add_calculator!(map,</span> <span class="pre">&quot;geometric_moments&quot;,</span> <span class="pre">GeometricMoments);</span></code>.
You’ll need to make sure to bring your new calculator in scope with a <cite>use</cite> item.</p>
<p>Additionally, you may want to add a convenience class in Python for our new
calculator. For this, you can add a class like this to
<code class="docutils literal notranslate"><span class="pre">python/featomic/calculators.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GeometricMoments</span><span class="p">(</span><span class="n">CalculatorBase</span><span class="p">):</span>
<span class="w"> </span><span class="sd">&quot;&quot;&quot; TODO: documentation &quot;&quot;&quot;</span>

   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">max_moment</span><span class="p">,</span> <span class="n">gradients</span><span class="p">):</span>
      <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;cutoff&quot;</span><span class="p">:</span> <span class="n">cutoff</span><span class="p">,</span>
            <span class="s2">&quot;max_moment&quot;</span><span class="p">:</span> <span class="n">max_moment</span><span class="p">,</span>
            <span class="s2">&quot;gradients&quot;</span><span class="p">:</span> <span class="n">gradients</span><span class="p">,</span>
      <span class="p">}</span>
      <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;geometric_moments&quot;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>


<span class="c1">#############################################################################</span>

<span class="c1"># this allows using the calculator like this</span>
<span class="kn">from</span> <span class="nn">featomic</span> <span class="kn">import</span> <span class="n">GeometricMoments</span>
<span class="n">calculator</span> <span class="o">=</span> <span class="n">GeometricMoments</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="mf">3.5</span><span class="p">,</span> <span class="n">max_moment</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">gradients</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># instead of</span>
<span class="kn">from</span> <span class="nn">featomic.calculators</span> <span class="kn">import</span> <span class="n">CalculatorBase</span>
<span class="n">calculator</span> <span class="o">=</span> <span class="n">CalculatorBase</span><span class="p">(</span>
   <span class="s2">&quot;geometric_moments&quot;</span><span class="p">,</span>
   <span class="p">{</span><span class="s2">&quot;cutoff&quot;</span><span class="p">:</span> <span class="mf">3.5</span><span class="p">,</span> <span class="s2">&quot;max_moment&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;gradients&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We have now finished our implementation of the geometric moments calculator! In
the next steps, we’ll see how to write tests to ensure the calculator works and
how to write some documentation for it.</p>
</section>
</section>
<section id="testing-the-new-calculator">
<h2>Testing the new calculator<a class="headerlink" href="#testing-the-new-calculator" title="Link to this heading">¶</a></h2>
<p>Before we can release our new calculator in the world, we need to make sure it
currently behaves as intended, and that we have a way to ensure it continues to
behave as intended as the code changes. To achieve both goals, featomic uses
unit tests and regression tests. Unit tests are written in the same file as the
main part of the code, in a <code class="docutils literal notranslate"><span class="pre">tests</span></code> module, and are expected to test high
level properties of the code. For example, unit tests allow to check that the
computed gradient match the derivatives of the computed values; or that the
right values are computed when the users requests a subset of samples &amp;
features. On the other hand, regression tests check the exact values produced by
a given calculator on a specific system; and that these values stay the same as
we modify the code, for example when trying to optimize it. These regression
tests live in the <code class="docutils literal notranslate"><span class="pre">featomic/tests</span></code> folder, with one file per test.</p>
<p>This tutorial will focus on unit tests and introduce some utilities for tests
that should apply to all calculators. To write regression tests, you should take
inspiration from existing tests such as <code class="docutils literal notranslate"><span class="pre">spherical-expansion</span></code> test. Each Rust
file in <code class="docutils literal notranslate"><span class="pre">featomic/tests</span></code> is associated with a Python file in
<code class="docutils literal notranslate"><span class="pre">featomic/tests/data</span></code> used to generate the values the regression test is
checking, so you’ll need one of these as well.</p>
<section id="testing-properties">
<h3>Testing properties<a class="headerlink" href="#testing-properties" title="Link to this heading">¶</a></h3>
<p>If this is the first time you are writing tests in Rust, you should read the
<a class="reference external" href="https://doc.rust-lang.org/stable/book/ch11-00-testing.html">corresponding chapter</a> in the official
Rust book for a great introduction to this subject.</p>
<p>Depending on the representation you are working with, you should write tests
that check the fundamental properties of this representation. For example, for
our geometric moments representation, the first moment (with order 0) should
always be the number of neighbor of the current atomic type over the total
number of neighbors. A test checking this property would look like this:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[cfg(test)]</span>
<span class="k">mod</span><span class="w"> </span><span class="nn">tests</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span><span class="p">::</span><span class="n">Calculator</span><span class="p">;</span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span><span class="p">::</span><span class="n">systems</span><span class="p">::</span><span class="n">test_utils</span><span class="p">::</span><span class="n">test_systems</span><span class="p">;</span>

<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">approx</span><span class="p">::</span><span class="n">assert_relative_eq</span><span class="p">;</span>

<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">ndarray</span><span class="p">::</span><span class="n">array</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#[test]</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">zeroth_moment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Create a Calculator wrapping a GeometricMoments instance</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">calculator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Calculator</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="nb">Box</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">GeometricMoments</span><span class="p">{</span>
<span class="w">            </span><span class="n">cutoff</span><span class="p">:</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span>
<span class="w">            </span><span class="n">max_moment</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">})</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">CalculatorBase</span><span class="o">&gt;</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// create a bunch of systems in a format compatible with `calculator.compute`.</span>
<span class="w">        </span><span class="c1">// Available systems include &quot;water&quot; and &quot;methane&quot; for the corresponding</span>
<span class="w">        </span><span class="c1">// molecules, and &quot;CH&quot; for a basic 2 atoms system.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">systems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test_systems</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">&quot;water&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CH&quot;</span><span class="p">]);</span>

<span class="w">        </span><span class="c1">// run the calculation using default parameters</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">descriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculator</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">systems</span><span class="p">,</span><span class="w"> </span><span class="nb">Default</span><span class="p">::</span><span class="n">default</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// check the results</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">descriptor</span><span class="p">.</span><span class="n">keys</span><span class="p">(),</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="p">[</span><span class="s">&quot;center_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_type&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">[[</span><span class="o">-</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">42</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]]</span>
<span class="w">        </span><span class="p">));</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">expected_properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">([</span><span class="s">&quot;k&quot;</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">0</span><span class="p">]]);</span>

<span class="w">        </span><span class="cm">/**********************************************************************/</span>
<span class="w">        </span><span class="c1">// O center, H neighbor</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">samples</span><span class="p">(),</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="p">[</span><span class="s">&quot;system&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atom&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]]</span>
<span class="w">        </span><span class="p">));</span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">(),</span><span class="w"> </span><span class="n">expected_properties</span><span class="p">);</span>

<span class="w">        </span><span class="n">assert_relative_eq</span><span class="o">!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">().</span><span class="n">as_array</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="o">!</span><span class="p">[[</span><span class="mf">2.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">]].</span><span class="n">into_dyn</span><span class="p">());</span>

<span class="w">        </span><span class="cm">/**********************************************************************/</span>
<span class="w">        </span><span class="c1">// H center, O neighbor</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">samples</span><span class="p">(),</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="p">[</span><span class="s">&quot;system&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atom&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span>
<span class="w">        </span><span class="p">));</span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">(),</span><span class="w"> </span><span class="n">expected_properties</span><span class="p">);</span>

<span class="w">        </span><span class="n">assert_relative_eq</span><span class="o">!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">().</span><span class="n">as_array</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="o">!</span><span class="p">[[</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">]].</span><span class="n">into_dyn</span><span class="p">());</span>

<span class="w">        </span><span class="cm">/**********************************************************************/</span>
<span class="w">        </span><span class="c1">// H center, H neighbor</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">samples</span><span class="p">(),</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="p">[</span><span class="s">&quot;system&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atom&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span>
<span class="w">        </span><span class="p">));</span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">(),</span><span class="w"> </span><span class="n">expected_properties</span><span class="p">);</span>

<span class="w">        </span><span class="n">assert_relative_eq</span><span class="o">!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">().</span><span class="n">as_array</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="o">!</span><span class="p">[[</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">]].</span><span class="n">into_dyn</span><span class="p">());</span>

<span class="w">        </span><span class="cm">/**********************************************************************/</span>
<span class="w">        </span><span class="c1">// H center, C neighbor</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">samples</span><span class="p">(),</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="p">[</span><span class="s">&quot;system&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atom&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]]</span>
<span class="w">        </span><span class="p">));</span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">(),</span><span class="w"> </span><span class="n">expected_properties</span><span class="p">);</span>

<span class="w">        </span><span class="n">assert_relative_eq</span><span class="o">!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">().</span><span class="n">as_array</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="o">!</span><span class="p">[[</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">1.0</span><span class="p">]].</span><span class="n">into_dyn</span><span class="p">());</span>

<span class="w">        </span><span class="cm">/**********************************************************************/</span>
<span class="w">        </span><span class="c1">// C center, H neighbor</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">block_by_id</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">samples</span><span class="p">(),</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="p">[</span><span class="s">&quot;system&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atom&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]]</span>
<span class="w">        </span><span class="p">));</span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">properties</span><span class="p">(),</span><span class="w"> </span><span class="n">expected_properties</span><span class="p">);</span>

<span class="w">        </span><span class="n">assert_relative_eq</span><span class="o">!</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">values</span><span class="p">().</span><span class="n">as_array</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="o">!</span><span class="p">[[</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">1.0</span><span class="p">]].</span><span class="n">into_dyn</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">featomic::systems::test_utils::test_systems</span></code> function provides a couple
of very simple systems to be used for testing.</p>
</section>
<section id="testing-partial-calculations">
<h3>Testing partial calculations<a class="headerlink" href="#testing-partial-calculations" title="Link to this heading">¶</a></h3>
<p>One properties that all calculators must respect is that computing only a subset
of samples or feature should give the same values as computing everything.
Featomic provides a function (<code class="docutils literal notranslate"><span class="pre">calculators::tests_utils::compute_partial</span></code>) to
check this for you, simplifying the tests a bit. Here is how one can use it with
the <code class="docutils literal notranslate"><span class="pre">GeometricMoments</span></code> calculator:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="cp">#[test]</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">compute_partial</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">calculator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Calculator</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="nb">Box</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">GeometricMoments</span><span class="p">{</span>
<span class="w">            </span><span class="n">cutoff</span><span class="p">:</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span>
<span class="w">            </span><span class="n">max_moment</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="w">        </span><span class="p">})</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">CalculatorBase</span><span class="o">&gt;</span><span class="p">);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">systems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test_systems</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">&quot;water&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;methane&quot;</span><span class="p">]);</span>

<span class="w">        </span><span class="c1">// build a list of samples to compute</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="p">[</span><span class="s">&quot;system&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atom&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span>
<span class="w">        </span><span class="p">);</span>

<span class="w">        </span><span class="c1">// create some properties. There is no need to order them in the same way</span>
<span class="w">        </span><span class="c1">// as the default calculator</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">([</span><span class="s">&quot;k&quot;</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]]);</span>

<span class="w">        </span><span class="c1">// Some keys (more than the calculator would produce by default)</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Labels</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="p">[</span><span class="s">&quot;center_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;neighbor_type&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">[[</span><span class="o">-</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">42</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]]</span>
<span class="w">        </span><span class="p">);</span>

<span class="w">        </span><span class="c1">// this function will check that selecting keys/samples/properties will</span>
<span class="w">        </span><span class="c1">// not change the result of the calculation</span>
<span class="w">        </span><span class="k">crate</span><span class="p">::</span><span class="n">calculators</span><span class="p">::</span><span class="n">tests_utils</span><span class="p">::</span><span class="n">compute_partial</span><span class="p">(</span>
<span class="w">            </span><span class="n">calculator</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">systems</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keys</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">samples</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">properties</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="testing-gradients">
<h3>Testing gradients<a class="headerlink" href="#testing-gradients" title="Link to this heading">¶</a></h3>
<p>If a calculator can compute gradients, it is a good idea to check if the
gradient does match the finite differences definition of derivatives. Featomic
provides <code class="docutils literal notranslate"><span class="pre">calculators::tests_utils::finite_difference</span></code> to help check this.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="cp">#[test]</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">finite_differences</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">calculator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Calculator</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="nb">Box</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">GeometricMoments</span><span class="p">{</span>
<span class="w">            </span><span class="n">cutoff</span><span class="p">:</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span>
<span class="w">            </span><span class="n">max_moment</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">        </span><span class="p">})</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">CalculatorBase</span><span class="o">&gt;</span><span class="p">);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test_system</span><span class="p">(</span><span class="s">&quot;water&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">crate</span><span class="p">::</span><span class="n">calculators</span><span class="p">::</span><span class="n">tests_utils</span><span class="p">::</span><span class="n">FinalDifferenceOptions</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">displacement</span><span class="p">:</span><span class="w"> </span><span class="mf">1e-6</span><span class="p">,</span>
<span class="w">            </span><span class="n">max_relative</span><span class="p">:</span><span class="w"> </span><span class="mf">1e-6</span><span class="p">,</span>
<span class="w">            </span><span class="n">epsilon</span><span class="p">:</span><span class="w"> </span><span class="mf">1e-9</span><span class="p">,</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">crate</span><span class="p">::</span><span class="n">calculators</span><span class="p">::</span><span class="n">tests_utils</span><span class="p">::</span><span class="n">finite_differences_positions</span><span class="p">(</span><span class="n">calculator</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">system</span><span class="p">,</span><span class="w"> </span><span class="n">options</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="documenting-the-new-calculator">
<h2>Documenting the new calculator<a class="headerlink" href="#documenting-the-new-calculator" title="Link to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Work in progress</p>
<p>This section of the documentation is not yet written</p>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="profiling.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Profiling calculation</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">How-to guides</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Guillaume Fraux, Philip Loche, Sergei Kliavinek, Kevin Kazuki Huguenin-Dumittan, Davide Tisi, Alexander Goscinski
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link fa-brands fa-github fa-2x" href="https://github.com/metatensor/featomic" aria-label="GitHub"></a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Adding a new calculator</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#the-traits-we-ll-use">The traits we’ll use</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a><ul>
<li><a class="reference internal" href="#calculator-metadata">Calculator metadata</a></li>
<li><a class="reference internal" href="#representation-metadata">Representation metadata</a><ul>
<li><a class="reference internal" href="#keys">Keys</a></li>
<li><a class="reference internal" href="#samples">Samples</a></li>
<li><a class="reference internal" href="#components">Components</a></li>
<li><a class="reference internal" href="#properties">Properties</a></li>
<li><a class="reference internal" href="#gradients">Gradients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-compute-function">The compute function</a></li>
<li><a class="reference internal" href="#registering-the-new-calculator">Registering the new calculator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-the-new-calculator">Testing the new calculator</a><ul>
<li><a class="reference internal" href="#testing-properties">Testing properties</a></li>
<li><a class="reference internal" href="#testing-partial-calculations">Testing partial calculations</a></li>
<li><a class="reference internal" href="#testing-gradients">Testing gradients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#documenting-the-new-calculator">Documenting the new calculator</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=9d584dea"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>