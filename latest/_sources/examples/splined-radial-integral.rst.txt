
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/splined-radial-integral.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_splined-radial-integral.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_splined-radial-integral.py:


Splined radial integrals
========================

.. start-body

This example illustrates how to generate splines and use custom basis function and
density when computing density-based representations, such as SOAP or LODE.

.. GENERATED FROM PYTHON SOURCE LINES 12-26

.. code-block:: Python


    import json

    import ase.build
    import matplotlib.pyplot as plt
    import numpy as np
    import scipy

    import featomic
    from featomic import SphericalExpansion
    from featomic.basis import RadialBasis
    from featomic.splines import SoapSpliner









.. GENERATED FROM PYTHON SOURCE LINES 27-38

For this example, we will define a new custom radial basis for the SOAP spherical
expansion, based on Chebyshev polynomials of the first kind. This basis will then be
used in combination with spherical harmonics to expand the density of neighboring
atoms around a central atom.

In featomic, defining custom radial basis is done by creating a class inheriting from
:py:class:`featomic.basis.RadialBasis`, and implementing the required method. The
main one is ``compute_primitive``, which evaluates the radial basis on a set of
points. This function should also be able to evaluate the derivative of the radial
basis. If needed :py:meth:`featomic.basis.RadialBasis.finite_differences_derivative`
can be used to compute the derivative with finite differences.

.. GENERATED FROM PYTHON SOURCE LINES 39-59

.. code-block:: Python



    class Chebyshev(RadialBasis):
        def __init__(self, max_radial, radius):
            # initialize `RadialBasis`
            super().__init__(max_radial=max_radial, radius=radius)

        def compute_primitive(self, positions, n, *, derivative=False):
            # map argument from [0, cutoff] to [-1, 1]
            z = 2 * positions / self.radius - 1
            if derivative:
                return -2 * n / self.radius * scipy.special.chebyu(n)(z)
            else:
                return scipy.special.chebyt(n + 1)(z)

        @property
        def integration_radius(self):
            return self.radius









.. GENERATED FROM PYTHON SOURCE LINES 60-61

We can now look at the basis functions and their derivatives

.. GENERATED FROM PYTHON SOURCE LINES 62-72

.. code-block:: Python

    radius = 4.5
    basis = Chebyshev(max_radial=4, radius=radius)

    r = np.linspace(0, radius)
    for n in range(basis.size):
        plt.plot(r, basis.compute_primitive(r, n, derivative=False))

    plt.title("Chebyshev radial basis functions")
    plt.show()




.. image-sg:: /examples/images/sphx_glr_splined-radial-integral_001.png
   :alt: Chebyshev radial basis functions
   :srcset: /examples/images/sphx_glr_splined-radial-integral_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 73-78

.. code-block:: Python

    for n in range(basis.size):
        plt.plot(r, basis.compute_primitive(r, n, derivative=True))
    plt.title("Chebyshev radial basis functions' derivatives")
    plt.show()




.. image-sg:: /examples/images/sphx_glr_splined-radial-integral_002.png
   :alt: Chebyshev radial basis functions' derivatives
   :srcset: /examples/images/sphx_glr_splined-radial-integral_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 79-83

Before being used by featomic, the basis functions we implemented will be
orthogonalized and normalized, to improve conditioning of the produced features. This
is done automatically, and one can access the orthonormalized basis functions with the
:py:meth:`featomic.basis.RadialBasis.compute` method.

.. GENERATED FROM PYTHON SOURCE LINES 84-93

.. code-block:: Python


    basis_orthonormal = basis.compute(r, derivative=False)
    for n in range(basis.size):
        plt.plot(r, basis_orthonormal[:, n])

    plt.title("Orthonormalized Chebyshev radial basis functions")
    plt.show()





.. image-sg:: /examples/images/sphx_glr_splined-radial-integral_003.png
   :alt: Orthonormalized Chebyshev radial basis functions
   :srcset: /examples/images/sphx_glr_splined-radial-integral_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 94-100

With this, our new radial basis definition is ready to be used with
:py:class:`featomic.splines.SoapSpliner`. This class will take the whole set of hyper
parameters, use them to compute a spline of the radial integral, and give us back new
hypers that can be used with the native calculators to compute the expansion with our
custom basis.


.. GENERATED FROM PYTHON SOURCE LINES 101-117

.. code-block:: Python


    spliner = SoapSpliner(
        cutoff=featomic.cutoff.Cutoff(
            radius=radius,
            smoothing=featomic.cutoff.ShiftedCosine(width=0.3),
        ),
        density=featomic.density.Gaussian(width=0.5),
        basis=featomic.basis.TensorProduct(
            max_angular=4,
            radial=Chebyshev(max_radial=4, radius=radius),
            spline_accuracy=1e-4,
        ),
    )

    hypers = spliner.get_hypers()








.. GENERATED FROM PYTHON SOURCE LINES 118-120

The hyper parameters have been transformed from what we gave to the
:py:class:`featomic.splines.SoapSpliner`:

.. GENERATED FROM PYTHON SOURCE LINES 121-125

.. code-block:: Python


    print("hypers['basis'] is", type(hypers["basis"]))
    print("hypers['density'] is", type(hypers["density"]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    hypers['basis'] is <class 'featomic.basis.Explicit'>
    hypers['density'] is <class 'featomic.density.DiracDelta'>




.. GENERATED FROM PYTHON SOURCE LINES 126-127

And the new hypers can be used directly with the calculators:

.. GENERATED FROM PYTHON SOURCE LINES 128-131

.. code-block:: Python


    calculator_splined = SphericalExpansion(**hypers)








.. GENERATED FROM PYTHON SOURCE LINES 132-134

As a comparison, let's look at the expansion coefficient for formic acid, using both
our splined radial basis and the classic GTO radial basis:

.. GENERATED FROM PYTHON SOURCE LINES 135-155

.. code-block:: Python


    atoms = ase.build.molecule("HCOOH", vacuum=4, pbc=True)

    calculator_gto = SphericalExpansion(
        # same parameters, only the radial basis changed
        cutoff=featomic.cutoff.Cutoff(
            radius=radius,
            smoothing=featomic.cutoff.ShiftedCosine(width=0.3),
        ),
        density=featomic.density.Gaussian(width=0.5),
        basis=featomic.basis.TensorProduct(
            max_angular=4,
            radial=featomic.basis.Gto(max_radial=4, radius=radius),
            spline_accuracy=1e-4,
        ),
    )

    expansion_splined = calculator_splined.compute(atoms)
    expansion_gto = calculator_gto.compute(atoms)








.. GENERATED FROM PYTHON SOURCE LINES 156-160

As you can see, the coefficients ends up different, with values assigned to different
basis functions. In practice, which basis function will be the best will depend on the
use case and exact dataset, so you should try a couple and check how they performe for
you!

.. GENERATED FROM PYTHON SOURCE LINES 161-168

.. code-block:: Python


    selection = dict(o3_lambda=0, center_type=8, neighbor_type=1)

    plt.matshow(expansion_splined.block(selection).values.reshape(2, 5))
    plt.matshow(expansion_gto.block(selection).values.reshape(2, 5))





.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/images/sphx_glr_splined-radial-integral_004.png
         :alt: splined radial integral
         :srcset: /examples/images/sphx_glr_splined-radial-integral_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/images/sphx_glr_splined-radial-integral_005.png
         :alt: splined radial integral
         :srcset: /examples/images/sphx_glr_splined-radial-integral_005.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.image.AxesImage object at 0x7f13049f23c0>



.. GENERATED FROM PYTHON SOURCE LINES 169-172

Since the calculation of the splines requires computing some integral numerically, the
creation of the splines might take a while. After an initial calculation, you can save
the splines data in JSON files; and then reload them later to re-use:

.. GENERATED FROM PYTHON SOURCE LINES 173-190

.. code-block:: Python


    # convert the hypers from classes to a pure JSON-compatible dictionary
    json_hypers = featomic.hypers_to_json(hypers)

    # save the data to a file
    with open("splined-hypers.json", "w") as fp:
        json.dump(json_hypers, fp)


    # load the data from the file
    with open("splined-hypers.json", "r") as fp:
        json_hypers = json.load(fp)

    # the hypers can be used directly with the calculators
    calculator = featomic.SphericalExpansion(**json_hypers)









.. GENERATED FROM PYTHON SOURCE LINES 191-197

Finally, you can use the same method to define custom
:py:class:`featomic.basis.ExpansionBasis` and custom
:py:class:`featomic.density.AtomicDensity`; by creating a new class inheriting from
the corresponding base class and implementing the corresponding methods. This allow
you to create a fully custom spherical expansion, and evaluate them efficiently
through the splines.

.. GENERATED FROM PYTHON SOURCE LINES 200-201

.. end-body


.. _sphx_glr_download_examples_splined-radial-integral.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: splined-radial-integral.ipynb <splined-radial-integral.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: splined-radial-integral.py <splined-radial-integral.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: splined-radial-integral.zip <splined-radial-integral.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
