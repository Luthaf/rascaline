searchState.loadedDescShard("featomic", 0, "Default, use all possible labels\nError used when a memory buffer is too small to fit the …\nParameters specific to a single call to <code>compute</code>\nErrors coming from external callbacks, typically inside …\nError used for failed internal consistency check and …\nGot an invalid parameter value in a function\nError while serializing/deserializing data\nRules to select labels (either samples or properties) on …\nErrors coming from metatensor\nUse a predefined subset of labels, with different entries …\nSelect a subset of labels, using the same selection …\nError due to C strings containing non-utf8 data\nCompute the descriptor for all the given <code>systems</code> and store …\nGet the all radial cutoffs used by this Calculator’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nList of gradients that should be computed. If this list is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ncbindgen:ignore\nGet the name of this calculator\nCreate a new calculator with the given <code>name</code> and <code>parameters</code>.\nGet the parameters used to create this calculator in a …\nSelection for the keys to include in the output. If this …\nSelection of properties to compute for the samples\nSelection of samples on which to run the computation\nThis module provides 3D vectors and matrix to be used in …\nCopy the data from systems into native <code>SimpleSystem</code>. This …\nAn atomic composition calculator for obtaining the …\nThe <code>CalculatorBase</code> trait is the interface shared by all …\nDefinition of the (atomic) density to expand on a basis\nDifferent available kinds of atomic density to use in …\nImplemented options for radial scaling of the atomic …\nDirac delta atomic density\nThis defines an explicit basis, where only a specific …\nGaussian atomic density <code>exp(-r^2/width^2)</code>\nUse a radial basis similar to Gaussian-Type Orbitals.\nUse a radial basis similar to Gaussian-Type Orbitals.\nThe different kinds of radial basis supported LODE …\nThis calculator computes the neighbor list for a given …\nSmeared power law density, that behaves like <code>1 / r^p</code> as <code>r</code> …\nThe different kinds of radial basis supported by SOAP …\nSorted distances vector representation of an atomic …\nPossible Basis functions to use for the SOAP or LODE …\nUse pre-tabulated radial basis.\nUse pre-tabulated radial basis.\nThis defines a tensor product basis, combining all …\nInformation about “tensor product” spherical expansion …\nUse a long-range algebraic decay and smooth behavior at …\nWeight of the central atom contribution to the density. If …\nGet the components this calculator computes for each key.\nActually run the calculation.\nEvaluate the radial scaling function at the distance <code>r</code>\nSpherical cutoff to use to determine if two atoms are …\nGet the all radial cutoffs used by this Calculator’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nShould we compute a full neighbor list (each pair appears …\nEvaluate the gradient of the radial scaling function at …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the set of keys for this calculator and the given …\nMaximal value (inclusive) of the angular moment (quantum …\nGet the name of this Calculator\nGet the parameters used to create this Calculator as a …\nSum atom numbers for each system.\nGet the samples for gradients with respect to positions, …\nGet the properties this calculator computes for each key.\nGet the names used for property labels by this calculator\nDefinition of the radial basis functions\nGet the names used for sample labels by this calculator\nGet the full list of samples this calculator would create …\nradial scaling can be used to reduce the importance of …\nShould individual atoms be considered their own neighbor? …\nGet the size (number of basis function) for the current …\nGet the size (number of basis function) for the current …\nAccuracy for splining the radial integral. Using splines …\nCan this calculator compute gradients with respect to the …\nExponent of the density (<code>p</code>)\nSmearing width of the density (<code>σ</code>)\nWidth of the gaussian, the same width is used for all atoms\nsee in the formula\nsee in the formula\nsee in the formula\nMaximal value of <code>n</code> to include in the radial basis function …\nRadius of the Gto basis, i.e. how far should the local …\nMaximal value of <code>n</code> to include in the radial basis function …\nA <code>LodeRadialIntegral</code> computes the LODE radial integral  …\nImplementation of the LODE radial integral for GTO radial …\n<code>LodeRadialIntegralSpline</code> allows to evaluate another radial …\nThe actual calculator used to compute LODE spherical …\nParameters for LODE spherical expansion calculator.\nDefinition of the basis functions used to expand the …\nCompute the LODE radial integral for a single k-vector <code>norm</code>…\nDefinition of the density arising from atoms in the whole …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>LodeRadialIntegralSpline</code> with user-defined …\nCompute the contribution of the central atom to the final …\nGet the value of the k-space cutoff (either provided by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSpherical reciprocal cutoff. If <code>k_cutoff</code> is <code>None</code>, a cutoff …\nCreate a new LODE radial integral\nGet how many basis functions are part of this integral. …\nCreate a new <code>LodeRadialIntegralSpline</code> taking values from …\nDefinition of a local environment for SOAP calculations\nParameters for SOAP power spectrum calculator.\nParameters for the SOAP radial spectrum calculator.\nShifted cosine smoothing function …\nPossible values for the smoothing cutoff function\nCalculator implementing the Smooth Overlap of Atomic …\nA <code>SoapRadialIntegral</code> computes the SOAP radial integral for …\nStore all <code>SoapRadialIntegralCache</code> for different angular …\nCalculator implementing the Radial spectrum representation …\nThe actual calculator used to compute SOAP spherical …\nThe actual calculator used to compute spherical expansion …\nParameters for spherical expansion calculator.\nStep smoothing function (i.e. no smoothing). This is 1 …\nDefinition of the basis functions used to expand the …\nDefinition of the basis functions used to expand the …\nDefinition of the basis functions used to expand the …\nCompute the radial integral for a single <code>distance</code> between …\nRun the calculation, the results are accessible with <code>get</code>\nDefinition of the atomic environment within a cutoff, and …\nDefinition of the atomic environment within a cutoff, and …\nDefinition of the atomic environment within a cutoff, and …\nDefinition of the density arising from atoms in the local …\nDefinition of the density arising from atoms in the local …\nDefinition of the density arising from atoms in the local …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet one of the individual cache, corresponding to the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>SoapRadialIntegralCacheByAngular</code> for the …\nCreate a new <code>SphericalExpansion</code> calculator with the given …\nAccess the spherical expansion parameters used by this …\nRadius of the spherical cutoff to use for atomic …\nGet how many basis functions are part of this integral. …\nEvaluate the smoothing function at the distance <code>r</code>\nCutoff function used to smooth the behavior around the …\nEvaluate the gradient of the smoothing function at the …\nValidate all the parameters\nWidth of the switching function\nAll of the given atoms types must be present. This can …\nCompute a set of keys with two variables: the central atom …\nAny atomic type is fine\n<code>SampleBuilder</code> for atom-centered representation. This will …\nAtomic type filters to be used when building samples and …\nCompute a set of keys with two variables: the central atom …\nCompute a set of keys with three variables: the central …\nCompute a set of keys with a single variable, the central …\nCommon interface to create a set of metatensor’s …\nSamples builder for long-range (i.e. infinite cutoff), per …\nAny of the given atomic type is fine\nAbstraction over the different kinds of samples used in …\nOnly the given atomic type should match\nFilter for the central atom type\nFilter for the central atom type\nspherical cutoff radius used to construct the …\nSpherical cutoff to use when searching for neighbors …\nSpherical cutoff to use when searching for neighbors …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a set of <code>Labels</code> containing the gradient samples …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompute the keys corresponding to these systems\nCheck if a given type matches the filter\nFilter for the neighbor atom type\nFilter for the neighbor atom type\nGet the names used by the samples\nCreate <code>Labels</code> containing all the samples corresponding to …\nShould the central atom be considered it’s own neighbor?\nShould the central atom be considered it’s own neighbor?\nShould we consider an atom to be it’s own neighbor or …\nShould we consider an atom to be it’s own neighbor or …\nAre neighbor atoms keys symmetric with respect to exchange …\nEuler’s constant\nA single k-vector and its norm stored together\nCompute a full set of spherical harmonics at given …\nArray storing data for <code>0 &lt;= l &lt;= l_max</code>, <code>-l &lt;= m &lt;= l</code>. This …\nGet the slice of the full array containing values for a …\nEvaluate all spherical harmonics for the given <code>direction</code>, …\nGenerate k-vectors up to a certain cutoff (in reciprocal …\ndirection of the k-vector (i.e. normalized vector)\n<code>erf</code> calculates the error function at <code>x</code>.\n<code>erfc</code> calculates the complementary error function at <code>x</code>.\nCompute exponential integral E1(x)\nCompute exponential integral Ei(x)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>SphericalHarmonicsArray</code> with the given …\nBuild a new <code>SphericalHarmonics</code> calculator with the given …\nlength of the k-vector\nThe shape of a cell determine how we will be able to …\nInfinite unit cell, with no boundaries\nA neighbor list implementation usable with any system\nOrthorhombic unit cell, with cuboid shape\nPair of atoms coming from a neighbor list.\nA simple implementation of <code>System</code> to use when no other is …\nA <code>System</code> deals with the storage of atoms and related …\nTriclinic unit cell, with arbitrary parallelepiped shape\nAn <code>UnitCell</code> defines the system physical boundaries.\nGet the first length of the cell (i.e. the norm of the …\nAdd an atom with the given atomic type and position to …\nGet the first angle of the cell\nGet the second length of the cell (i.e. the norm of the …\nGet the second angle of the cell\nGet the third length of the cell (i.e. the norm of the …\nGet the Cartesian representation of the <code>fractional</code> vector …\nGet the unit cell for this system\nHow many cell shift where applied to the <code>second</code> atom to …\nCompute the neighbor list according to the given cutoff, …\nCreate a cubic unit cell, with side lengths …\nthe cutoff used to create this neighbor list\ndistance between the two atoms\nGet the distances between faces of the unit cell\nindex of the first atom in the pair\nGet the fractional representation of the <code>vector</code> in this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the third angle of the cell\nCreate an infinite unit cell\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this unit cell is infinite, <em>i.e.</em> if it does not …\nGet the matricial representation of the unit cell\nCreate a new empty system with the given unit cell\nCreate an orthorhombic unit cell, with side lengths <code>a, b, c</code>…\nGet the list of pairs in this system. This list of pair …\nall pairs in the system\nall pairs associated with a given atom\nGet the list of pairs in this system which include the …\nGet the positions for all atoms in this system. The …\nindex of the second atom in the pair\nGet the cell shape\nGet the number of atoms in this system\nCreate a triclinic unit cell, with side lengths <code>a, b, c</code> …\nGet the atomic types for all atoms in this system. The …\nvector from the first atom to the second atom, accounting …\nGet the volume of the cell\nA 3x3 square matrix type.\nA 3-dimensional vector type\nComputes the determinant of a matrix\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the inverse of a matrix\nGet the maximal value in this vector, using <code>std::f64::max</code> …\nGet the minimal value in this vector, using <code>std::f64::min</code> …\nCreate a new <code>Vector3D</code> with components <code>x</code>, <code>y</code>, <code>z</code>\nCreate a new <code>Matrix3</code> specifying all its components\nReturn the euclidean norm of a <code>Vector3D</code>\nCompute the (Frobenius) norm of the matrix\nReturn the squared euclidean norm of a <code>Vector3D</code>\nNormalize a <code>Vector3D</code>.\nCreate an identity matrix\nCreate a new <code>Vector3D</code> with components all components set …\nReturns rotation matrix given a rotation angle and an axis.\nTensorial product between vectors. The tensorial product …\nCompute the trace of the matrix\nTranspose this matrix into a new matrix\nCreate a new <code>Vector3D</code> with components <code>0</code>, <code>0</code>, <code>0</code>\nCreate a new <code>Matrix3</code> with components set to <code>0</code>")